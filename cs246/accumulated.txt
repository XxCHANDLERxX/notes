CS246 Object Oriented Software Development
Fall 2014
Lecture 1 (September 9 2014)
------------------------------------------

Nomair ("Numer[ical]") Naeem
    Also taught: CS241 'baby compilers course', CS444 'advanced compilers course'
    nanaeem@uwaterloo.ca 'prefer not to get emails for general course-related questions'

Course Breakdown:
    Final Exam - 40% - 2.5 hours
    Midterm - 20% - October 23rd - 4:30-6:20 (typical average 55-65% 'nice wake up call')
    Assignment - 40% - Six of them - A0 already out, worth no marks, prereq for future marks
        A1-A4 - worth 7% each, done individually
        A5 - worth 12%, small-medium sized project in groups of two, partner doesn't have to be in same section (same time frame as typical assignment, ~2 weeks)

        Two due dates - end of first week, end of second week
        Using Marmoset
        ISA: Kristen Bradley
        Tutorials: 'not compulsory, but encouraged', none in first week
        Lab hours in week 1: help for a0, MC 2062/2063, email cs246@uwaterloo.ca for help, 10-12, 2-3
        Piazza: monitor daily, check for already answered questions
        Reference materials: textbook not required, no course notes
        Academic integrity: 'do not cheat', 0% on assignment and -5% on course mark
        Welcome to second year: assignments get more difficult, longer description, less spoon-feeding, READ QUESTIONS MULTIPLE TIMES, no solutions provided

    You must use a *nix environment or SSH+WinSCP or Cygwin
    Use the cs136 virtual box (works fine until a3), not recommended
    MANAGE YOUR TIME

4 MODULES
    1 - Introduction to Unix Shell (2-3 weeks)
    2 - C++ 03 'Object Oriented Software Development' (10 weeks)
    3 - Tools
    4 - Software Engineering Principals

Module 1: Linux Shell
    interactive environment  - an interface to the Operating System
    Shell: how we get the OS to do "things" for us.
    Two kinds of shells:
        - Graphical
        - Text-based (command line)

    1. Graphical (eg. Windows, OSX, Gnome, KDE)
        + Intuitive to use
        + Mouse clicks
        + Drag and drop
        - harder (difficult) to do less common tasks (eg. batch-renaming of files ending in cpp to cc)

    2. Command Line Shell
        Interface to unix/linux environment
        Even Windows has a command-line shell (DOS)
        + Much more powerful
        - Must learn basic commands (steep learning curve)

    History of UNIX Shell:
        Linux has its roots in the original unix OS (70s)
            - The original unix had a command line shell ("Shell", "BourneShell" to differentiate)
            - Written by Stephen Bourne
        Other Shells:
            - CShell (csh)
            - KornShell (ksh)
        These shells also evolved
            - csh became tcsh
            - BourneShell became BourneAgainShell (BASH)
        Command: echo $0
            > 'bash' ($>) or 'tcsh' (%>)

    Linux File System
        - Contains files
            - files (data/programs) 'ordinary files'
            - directory (can contain other files) 'just like folders in Windows'
            /
                bin/
                    bash/
                    ls/
                    cd/
                etc/        (configuration files)
                    shells
                home/
                    nanaeem/
                        cs241/
                        cs246/
                usr/        
                    bin/    (user programs)
                    include/    (C headers are located)
        - Root of the tree structure is a dir called '/'
        - Can have two files with identical names as long as they are in different directories
        - We can specify any file by giving its path
        - '/bin' means 'bin' directory inside '/' directory
        - '/user/bin' - bin directory inside the 'usr' directory inside the '/' directory
        - Current Directory:
            - The directory we are currently in
            - Command 'pwd' (present working directory) outputs current directory
---------------------------------------------------------
Lecture 2

Directories start from root '/', these are absolute paths
Relative paths start from the current directory
    If current dir is '/home/nanaeem/cs246', then the file (remember, directories
    are actually files) 'Fall/a0' is the same as '/home/nanaeem/cs246/Fall/a0'.
    The advantage of relative paths is that it reduces typing.

Four different special directories:
    1. '.' - refers to current directory
        eg. '$> cd .'  does nothing
    2. '..' - refers to the parent directory
        eg. '$> cd ..' changes pwd to parent directory
        If you want to get to the grandparent, '$> cd ../..'
    3. '~' (Tilde) refers to the home directory
        '$> cd ~' changes to home directory
        Shortcut: '$> cd'
        Can continue path '~/cs246/Spring'
    4. '~userid' - userid's home directory (useful for sharing files between unix accounts)
        eg. '$> cd ~nanaeem'

To see the contents of a directory use 'ls' command (listing).
    - Shows files in your current directory
    - Does not show hidden files (starting with '.', icluding special dirs './' and '../') by default
    - 'ls -a' shows all files

In unix, there is no concept of file extensions (like .txt), although conventions are often enforced.

Wildcard Matching
        List all files ending with '.txt':
                '$> ls *.txt'
                       ^^^^^ globbing pattern
                       ^     match anything
                        ^^^^ that ends with '.txt'
                'globbing' comes from a legacy Glob program that performed wildcard searches
                The shell finds all the files that match the globbing pattern, and replaces the globbing pattern with those files.
                'ls *.txt' --> 'ls sample.txt t1.txt t2.txt'
                The shell is doing the hard work here.

                Behaves the same here as 'echo *.txt'
'$> rm' removes (permanently) the specified file(s)
    - University pays $45k a year with snapshot
    - 'Google version control'

'$> echo' parrots whatever the input is.
    '$> echo '*.txt'' outputs *.txt
    Single quotes and double quotes behave the same here.
    Do a 'man ls'.

CTRL-C to kill execution of curent program.
CTRL-D sends EOF. (Useful for telling cat to stop listening to stdin and clean up execution)
Working with files
    '$> cat' (concatenate)
        Show or display contents of a file.
        Simply typing 'cat' will hang the program until text is input.
        'cat > output.txt' output redirection
        If output.txt exists already, it will be overwritten.
        After pressing Enter, the line is written to the file.

    In general: 'command args > filename' puts any output into file
    This is called output redirection.

    Input redirection: 'cat < sample.txt', which is equivalent to 'cat sample.txt' here. But with redirection, the shell is opening the file instead of cat.
        If file contains another filename, it only prints the filename.

    '$> wc filename' wordcount
    'wc sample.txt' outputs filename because wc opens the file, but with 'wc < sample.txt', wc doesn't know the filename
    'cat < output.txt > myfile.txt'
    Note that shell commands will create the file if it doesn't exist, or overwrite the file if it does!

Every process is attached to three streams:
                          /--- stderror (standard error)
    stdinput --- [program]
                          \--- stdout (standard output)

    stdin - Where the input comes from (default: the keyboard).
    stdout - Where the output goes (default: screen). This is buffered, and flushed periodically.
    stderr - Where the errors go (default: screen). Seen immediately, one character at a time (never buffered).

    Input redirection changes stdin from keyboard to files (or socket from the internet, etc.)
    $> myprogram < in.txt > out.txt 2> error.log
        '2>' handles stderr stream

What if you want to append to a file? Go to the tutorial.

Pipes ('|')

                                        /--- stderror2
    stdout1 | stdinput2 --- [program2]
                                        \--- stdout2

    Pipe output of process 1 into process 2.
    '$> process1 | process2'
    (| is also bitwise OR in C)

    Example 1: How many words occur in the first twenty lines of sample.txt?
    '$> head -20 sample.txt | wc -w' --> 165

    Example 2: Suppose files w1.txt and w2.txt contain lists of words, one per line. Print a duplicate-free list of all words.
    uniq - checks for duplicates that are adjacent, so we must sort first.
    sort - sorts
    '$> cat w1.txt w2.txt | sort | uniq'
-----------------------------------
Lecture 3

Pipes
    last class:
        head -20 sample.txt | wc -w

    Equivalent to:

        head -20 sample.txt > temp.txt
        wc -w temp.txt

    The benefit of using pipes is to prevent using time/memory to write output to the disk.

How to pass the output of a program as an argument to another program.
    e.g. $ echo Today is date and I am whoami
    --> Today is date and I am whoami

    Put command in back-quotes (under tilde): Today is `date` and I am `whoami`
        7 words act like 7 arguments passed to echo.
    Also valid: echo "Today is `date`" (shell can execute commands in double quotes)
                echo Today is $(date)  (this syntax has the advantage of nesting without messy escaping)

Pattern Matching Inside Files
    Tool: grep (Global Regular Expression Pattern) (outdated)
          egrep (Extended '''), equivalent to grep -E

        Usage: $ egrep pattern file
        Output: lines in file that match the pattern

        e.g. Find all occurences of cs246 in index.shtml
              $ egrep cs246 index.shtml
              --> All lines of html containing substring "cs246"
        
        Find occurences of 'CS246' or 'cs246'
        Student: {CS,cs}, egrep -e?
        OR '|': egrep cs246|CS246 index.shtml --> bash interprets this as a pipe!
            Use quotes: egrep 'cs246|CS246' index.shtml
            Or, alternatively:
            egrep "(CS|cs)246" index.shtml
            egrep "(c|C)(s|S)246"

Use Regular Expressions
    e.g. lines that contained cs246 OR CS246
        "cs246|CS246"
        ===
        "(cs|CS)246"
        !==
        "(c|C)(s|S)246"

    a|b|c|d (a or b or c or d)
    Instead, use square brackets: [abcd]
        This chooses one character from this set.
    Ranges: [0-9]
        This chooses one digit from 0 to 9.

    All characters except certain characters: [^abcd]
        Any one character *except* a character from this set.

    e.g. What if we want an optional space between cs and 246?
        '?' is used to indicate 0 or 1 of the preceeding expression.
            $ egrep "cs( )?246" index.shtml
                Equivalent to: "cs ?246" without parenthesis, the preceeding expression/character is used (but brackets are encouraged)

    '*' is used to indicate 0 or more of the preceeding expression.
        e.g. egrep "(cs)*246" index.shtml
            --> 'cs246', '246', 'cscs246', 'cscscs246', ...
        If one line is matched it gets printed regardless of multiple matching cases.
        Cases regarding smallest/biggest matches, 'greedy' matching algorithms (largest match) are discussed in cs240.

    How do you find a '*' or a '?'?
        Escape it using '\'.
        e.g. "cs\?246"
            This escapes the special symbols (anything that has meaning within a regex)

        Remember - "Am I writing a globbing pattern or a regex?"
            Globbing pattern: '*' matches anything
            Regex: match 0 or more

    Dot ('.') matches any one symbol.
        e.g. egrep "cs.*246" index.shtml
            This matches ~~~cs~~~~~~246~~~, e.g. 'FOOcs246BAR'

    Carat ('^') (outside brackets) matches patterns at the beginning of the line.
        e.g. "^cs246"
            This gives all lines that start with cs246.

    Dollar ('$') matches ending characters.
        e.g. egrep "cs246$"
            This gives all lines that start with cs246.
        e.g. egrep "^cs246$"
            This gives all lines that contain exactly this string.

    Plus ('+') matches one or more of the preceeding expression.
        e.g. egrep ".+" index.shtml
            This prints all non-empty lines.

    *Note that there is a difference tbd between single and double quotes.

Useful egrep switches:
    Print all words of even length from /usr/share/dict/words
        Incorrect: $ egrep "(..)+" /usr/share/dict/words
            This returns all lines, since this isn't starting at the beginning of the line. All even substrings get found!
        Correct: $ egrep "^(..)+$" /usr/share/dict/words

    *Don't forget ^$ on the assigment!

    Print all files in the current directory whose name contain exactly one 'a'.
        $ ls | egrep "^[^a]*a[^a]*$"

    Print all words in /usr/share/dict/words that starts with an e and has length 5.
        $ egrep "^e....$" /usr/share/dict/words

----------
$ egrep -i
    This ignores case

$ egrep ./*
    Globs all files in directory.

$ egrep -R
----------

File Permissions
    $ ls -l
        Long listing that gives additional information on each file.
            Contains permissions strings!
        -rw-r--r-- 1 nanaeem staff 10K [Date Modified] [Filename]
                   ^ indicates number of symbolic links to this file
                        if this is a directory, indicates number of files within + number of sym links to the dir
                        'all references to this file'
                     ^^^^^^^ owner
                              ^^^^^ group
                                     ^^^ size
            '-' indicates ordinary file
            'd' indicates directory
            'l' indicates symbolic link (shortcuts)

    Group: way to share files in linux.
        A linux user can belong to many groups.
        A file can belong to one group.

        Permission: 3 groups of 3 bits
            User bits, group bits, other bits
            r -> read or set to '-'.
                File: read (cat, etc.). Directory: read contents of directory (ls, etc.).
            w -> write or set to '-'.
                File: write (vi, etc.). Directroy: modify contents (add/remove files, etc.).
            x -> execute or set to '-'.
                File: treat a file as a program and try to run it. Directory: you can enter that directory (cd, etc.).
            All On: rwxrwxrwx
            All Off: ---------
            Read, write, execute
        e.g. -rw-r--r-x
            Owners (user) can read and write, group can read, others can read and execute.
        chmod
-----------------------------------------------------------------------
Lecture 4

File Permissions:
    The owner of a file is the only one who can change file permissions
        You can't grant the permission for other users (non-owners) to change permission
    $ chmod [mode] [file]
        changes permissions
        Mode:
            ownership class:
                u = user
                g = group
                o = others
                a = all
            operator:
                + add permission
                - remove permission
                = set exactly
            permission:
                r read
                w write
                x execute

    e.g. Give others read permission
        chmod o+r file.txt         *Implicitly removed pre-existing permission

    You can specify mode with 3-digit numbers (you don't have to know this)

    e.g. Revoke execute permission from group
        chmod g-x file.txt

    e.g. Make everyone's permission exactly rx
        chmod a=rx *.cc     *If it was a+rx, a pre-existing w permission wouldn't be overwritten

    e.g. Change owner's permissions
        chmod u-rwx *.*         *You always have permissions. You can always re-give yourself permissions.

Scripting
    e.g. $ x=1            *No spaces, or else it'll try to execute a program
         $ echo $x

         To set a variable do not use $
         To access the value of a variable use $ and {}
             e.g. ${x}
         The value of a variable is always a string
             e.g. x=1         *1 is the string '1'

    Some variables are global:
        Path - variable
            Colon-separated list of linux paths.
            Used for ls as ls is not built in. Shell looks in all directories specified in path.
            *Do not overwrite path

    .bashrc (how to set variables that stay)

    A script is a file containing a sequence of linux commands which we can execute as a program.
    e.g. Print the date, current user, and current directory.
        ./basic:

        #!/bin/bash               "hash, bang; shebang line"
        date
        whoami
        pwd

    Command line arguments to a script:
        inside the script:
            $1 first arg
            $2 second arg
            .
            .
            .
            $n nth arg

        e.g. Check whether the input word is in the dictionary.
            #!/bin/bash
            egrep "^$1$" /usr/share/dict/wprds
            Right now, if $1 is a word, $1 will be printed. Else, nothing is printed.

        e.g. A good password is not a word in the dictionary. Answer whether the password is good.
            #!/bin/bash
            egrep "^$1$" /usr/share/dict/words > /dev/null      "black hole used to discard input"
            if [ $? -eq 0 ]; then
                echo "Not good password."
            else echo "Maybe not a good password."
            fi          "This closes the if statement."

            *-ne Not Equal
            *-lt Less Than

        'if' is running a program called '['
            Anything after '[' are arguments.
            '[' evaluates condition, sets status code
            'if' checks the status code

        Look at:
            goodpassword check  *${#} contains the number of arguments to the script
            goodpassword usage () { }    *A function.

    General format for an if statement:
        if [ condition ]; then
            # Block of code.
        elif [ condition ]; then
            # Block of code.
        else # Line of code.

        "Look at rename c and count words for loops"
-------------------------------------------------------
Lecture 5

Loops
    e.g. Print all numbers from 1 to $1 ($1 is the first argument to our script)
    #!/bin/bash
    # count limit ---counts the numbers from 1 to limit
    usage () {
        echo: "Usage: $0 limit" 1>&2
        echo " where limit is at least 1" 1>&2
        exit 1
    }

    if [ $# -ne 1 ]; then
        usage
    fi

    if [ $1 -lt 1 ]; then
        usage
    fi

    x=1
    while [ $x -le $1 ]; done            # 'le' less than or equal
        echo $x
        x=$((x+1))            # "$x+1" would do string concatenation
    done

For Loop
e.g. Rename all .cpp files to .c     # scripts/RenameC
#!/bin/bash
for name in *.cpp; do
    mv ${name} ${name%cpp}cc
done

Here, the shell replaces *.cpp with a space delimited list of filenames. (a1.cpp a2.cpp ...) (globbing pattern gets replaced just before the loop's execution starts)

e.g. How many times does word($1) occur in the file($2)
#!/bin/bash
x=0
for word in `cat "$2"`; do             # 'for word in cat $2' (without backquotes) will get the word 'cat' then the filename 
                                    # GOTCHA: put double quotes around command arguments (without, strings with spaces are treated as multiple objsects, such as "hello word")
    if [ $word = $! ]; then         # '=' is used for string equality (strings on both sides) or for arithmatic (integer values)
        x=$((x+1))
    fi
echo $x
done

Payday is the last Friday of the month.
What date is this month's payday?
$ cal | awk '{print $6}' | egrep [0-9] | tail -1
/cs246/1149/lectures/shell/scripts/paydayThisMonth
# elif [ $1 -eq 22 ]; then
#    echo "on the ${1}nd"


Testing
    In this course, you will be expected to formally test your code before submitting.
    - Use the script we ask you to write in a1 (runsuite)
    Each assignment has 2 deadlines
        Due date 1: test suites
            Run on a correct program (public)
            Release tests are buggy programs that we created. "The test suite that you created should be thorough enough to catch all of our bugs."
        Due date 2: code
    Testing tips:
        negative/positive values
        edge cases [0-10] check 0 and 10
        corner cases (multiple simultaneous boundaries)
    This is black box testing (we do not see the implementation)
    White box: full access to implementation
    Grey box testing: some limited acces to control flow of the program

    *Read through assignment very carefully
    *Think carefully about what the edge/corner cases are, etc. (max X, max Y)

Module 2: C++
Bjarne Stroustrup in the 80s
    Worked at AT+T labs (same place where UNIX and C were invented)
    Colleagues were inventors of C, UNIX
    Playing with the language called Simula67 (considered the first OOP language)
    Came up with 'C with Classes'
C++ is too big to cover in one course.
We will introduce the core concepts.
We will focus on C++03, which is reasonably sized
    New version is C++11, which has sme very sophisticated new concepts.
    UW's CSCF/MFCF still don't support C++11

hello.cc:
--------------------------------------
#include <iostream>
using namespace std;

int main() {
    cout << "Hello World" << endl;
    return 0;                            // return statement must be explicitly defined in c++
}
--------------------------------------

Output in C:
#include stdio
printf('Hello World')

stdio/printf is available in c++, but DON'T USE IT!

Preferred c++ I/O
    #include <iostream>     (no .h)
    std::cout << data1 << data2;
    std::endl;          // newline (\n)

Using G++ compiler
Compile:
    $ g++ hello.cc
    Creates an executable called a.out (default name)
    $ g++ hello.cc -o myprog
    Creates an executable called myprog

    Execute with $ ./a.out, $ ./myprog
----------------------------------
Lecture 6

Clarification: Arguments vs. Input
    $ prog a1 a2
        "Two arguments. We're assuming the program knows how to handle this. The program can still read input from stdin, things you type." -NN
    $ prog a1 a2 < file.txt
        "Whenever you want to read input, read from the file. Faucet of data is just waiting there." -NN
    "I would highly recommend looking at diff, and what status codes it sets. Diff will set ${?} to 0 if different and 1 if not the same."

Recall:
    cout << stuff << endl;         // endl is optional, it just adds a new line
    C++ provides three I/O stream objects
        cout: print to stdout
        cin: reads from stdin
        cerr: prints to stderr

I/O Operators
    <<: output operator, "put to" operator
    >>: input operator, "get from" operator

    e.g.
        cout << x; // put x to stdout
        cin >> y; // get from stdin into y
        cerr << z; // put z to stderr

        "The arrow is in the direction of information flow."

intro/plus.cc (Reads 2 numbers and adds them.):

    #include <iostream>
    using namespace std;
    // Won't write the above two lines any more.

    int main () {
        int x, y; // two int vars
        cin >> x >> y;
        cout << x + y << endl;
    }

    // Whitespace delimits strings from stdin. "./plus" then "4 5" is sufficient.
    // ./plus, 4 five --> 4
    //        y is not necessarily set to zero, it is a garbage stack location

    cin is waiting for input, ignoring whitespace.
    If a read fails, the program will move on! This is troubling.
        Scary that there is no indication of failed read.
        If a read fils then cin.fail() is true.
        If a read fails due to end of input then both cin.fail() and cin.eof() are true.

e.g. Read all integers from stdin and print them, one per line, on stdout. Stop if a non-integer or EOF is encountered.
lectures/io/readInts.cc

int main () {
    int i;
    while (true) {
        cin >> i;
        if (cin.fail()) break;
        // come here only if read is successful
        cout << i << endl;
    }
}

./a.out:
3
3
4
1 2 3 4
5
2
five
^ program terminates here when these characters are encountered.

CTRL-D or CTRL-C will also terminate. cin.fail() and cin.eof() flags will both be raised if we do that.

There is an implicit conversion from cin to void*. "A pointer with no type, or a pointer that can point to anything."
    "cin is a stream object of type istream"
    void* is a pointer to anything. It's key here that we can treat something as a pointer.
    A pointer is a numeric quantity
    if (cin) // true if !cin.fail(), false otherwise

    Now we can do "if (!cin) break;"

We have said that >> is the input operator.
In C/C++, >> is the right bit shift operator;
    a>>3; // 10101 >> 3 = 00010 (21 -> 2) (divides by 2^3)
These operators are overloaded.
    a>>3; vs cin>>y; have different meanings.
    Compiler checks left hand side
    LHS: int
        treats >> as bit shift operator
        result: int
    LHS: istream
        treats >> as input operator
        result: cin (an istream)
        This is useful for using multiple operators in series.
            cin >> x >> y
            Here, "cin >> x" results in a cin object (and in x having a value)
                This becomes "cin >> y", which results in cin; which ends.
        This is called casdading.
            We've already taken advantage of this, e.g. "cout << i << endl"
        You can cascade as many times as you want.
            cin >> x >> y >> z >> a;
                If cin fails early on, all subsequent reads fail.
    We can combine 2 lines in readInts.cc:
    if (!(cin >> i)) break; // "cin >> i" mutates i and evaluates to cin, which evaluates to binary based on whether the read was successful.

Rewriting readInts.cc (readInts4.cc):

int main () {
    int i;
    while (cin >> i) {  // Works if we only care about reads failing. Does not check for EOF. BE ABLE TO EXPLAIN THIS ON THE MIDTERM! (produces cin, converts to void*)
        cout << i << endl;
    }
}

e.g. Read all ints and echo them to stdout. Skip non-integers. Terminate at EOF.
    (Can't use simplified code above, since we need to distinguish _why_ the read fails.)

int main () {
    int i;
    while (true) {
        if (!(cin >> i)) { // something failed, this is the fail block
            if (cin.eof()) break; //done
            else { // bad read (received a non-integer)
                // for non-integer reads, we could:
                //        a) do nothing (but this will loop infinitely, because the fail flag will still be raised (cin.fail() is true)! )
                //             recall: "once a read fails, all subsequent reads fail"
                //         b) clear the flag: cin.clear();
                //             if we only do this, we loop forever because that bad input is still there, even though the fail flag is cleared
                //         c) ignore the bad input: cin.ignore();
                //             This works! :)
                cin.clear();
                cin.ignore();
                // (!(cin >> i)) continues successfully now.
            }
        } else {
            cout << i << endl;
        }
    }
}

"You will be tested on these technical details on the midterm." -NN
Look at http://stackoverflow.com/a/6791854  -JR
---------------------------------------------------------------
I missed lecture 7.
The following is transcribed from Anna Lorimer's written notes.
---------------------------------------------------------------
Lecture 7

Streams

C++ Provides a string type: std::string
    Available in io/readstrings:


    #include <iostream>
    #include <string>

    int main () {
        string s; // you only have to change the type
        cin >> s;
        cout << s << endl;
    }


    *cin reads until whitespace

If you want to read in an entire line, use getline:
    getline(cin, s); // s is a string variable
        This reads until newline

In C you would use scanf with format specifiers.
    You don't need format specifiers in C++ (%s string, etc.)

How would you format cout? I/O Manipulators.
    e.g. cout << hex << i;
        hex is an i/o manipulator that prints i in hexadecimal
        This works by sending hex to cout. Nothing is printed but it changes how cout behaves by telling cout to set itself to hexadecimal.
        You have to reset cout after if you no longer want hex.
            e.g. cout << dec; // changes hex to decimal

There are lots of I/O manipulators:
    Look at <iomanip> header
    e.g. Left and right precisions (justifications)
        cout.width(20);
        cout << left << "Left alligned!" << endl;
        cout << right << "Right alligned!" << endl;

Stream abstraction works for other sources of data.
    How to read from a file:

    #include <fstream>  // gives you access to ifstream (read) and ofstream (write)
    #include <iostream>
    using namespace std;

    int main () {
        ifstream f("suite.txt"); // here "ifstream" is the type, "f" is the name of the variable (*cough*OBJECT*cough* -JR), and "suite.txt" is the initialization.
        string s;
        while (f >> s) {  // while read is successful
            cout << s << endl;
        }
    }

    Anything you can do with cin (i.e. istream), you can do with a variable (f) of type istream.
        Same for cout and ofstream.

    You can treat a string as the source of input (input string).
    You can also write to a string.
        Include <sstream> which gives you istringstream (input) and ostringstream (output)

    Example: buildstring.cc

    
    int low = ...;  // constant string
    int high = ...;
    ostringstream ss;
    ss << "Enter a number between" << low << "and" << high << endl
    string s = ss.str(); // extract a string out of ostringstream
    cout << s;


    This is useful for converting a string to a number.

    getnum.cc:

    #include <iostream>
    #include <string>
    #include <sstream>
    using namespace std;

    int main () {
        int n;
        while (true) {
            string s;
            cout << "Enter a number:" << endl;
            cin >> s;
            istringstream ss(s);
            if (ss >> n) break;  // read int from ss

            cout << "That's not a number! Try again:" << endl;
        }
        cout << "You entered " << n << endl;
    }


    Look at readints5.cc and readintsSS.c, they do the same thing.

    *The only time reading in a string fails is EOF.

Strings
    In C we don't have strings, we have NULL-terminated character arrays.
        This is annoying, namely the fixed size thing.
        You might accidentally overwrite the null terminator.
    C++ also has no built in strings, but provides string type.
        This grows and shrinks as needed.

        Example: string s = "Hello"; // type of s is stdstring, type of "Hello" is a C-style string (i.e. a character array that is NULL-terminated)
        *You're assigning a C-style string to a C++ string -> should give a compiler error!
        C++ has a special feature which converts a C-style string to a C++ string (they are NOT the same).

---------------- In C ---- vs. -- In C++ ---
Equality      | strcmp()      | s1 == s2
              |               |
Inequality    | strcmp()      | s1 != s2
              |               |
Comparisons   | strcmp()      | <, >, ==
              |               |
Length        | strlen()      | s.length()
              |               |
Concatenation | strcat()      | s = s1 + s2
--------------------------------------------

In C you can directly access individual characters in a string.
    You can still do this in C++ (individual access)
    This is done with overloading square brackets [].
    Example:
        std::strings = ...;
        s[0], s[1], ... are accessible
----------------------------------------------------------
Lecture 8

Assorted Goodies
Default Arguments
    void printSuiteFile(string filename = "mytests.txt") {
        ifstream myfile(filename.c_str()); // ifstream arg must be a 'C-style string', not string object. (won't compile if only calling with 'filename')
        string s;
        while (myfile >> s) {
            cout << s << endl;
        }
    }

You can get a c style string from std::string using the following:
    filename.c_str();

printSuiteFile(); // use the default value
printSuiteFile("suite.txt"); // use the specified arg

Optional arguments must appear last!
A default argument cannot be followed by a non-default argument.

void testParams(int num=0, string city="Waterloo")

testParams(5, "Toronto"); // legal
testParams(5); // legal
testParams(); // legal
testParams("Montreal"); // not legal
testParams( , "Montreal"); // not legal
*Can't assign city="Montreal" while calling, as in Python

Overloading (Function Overloading)
------------------------------------
int negate (int a) {
    return -a;
}
bool negate (bool a) {
    return !a;
}
-----------------------// in c, this won't compile! Functions must have a unique name.

In C++, this works. We have overloaded the negate function.
The C++ compiler looks at the name of the function, number of arguments, and types of arguments.
"What identifies a function is not only its name, but its argument types."

Function Header (Signature)
    In C++: name + types of arguments

In C++, you cannot have two functions that only differ in their return type.

Recall: '<<' operator
    Actually implemented in C++ as a function:
        ____ operator<<( , ) { ... }
        int operator<<(int, int) { ... } // returns int
        istream operator<<(istream, int) { ... } // returns istream "not exactly correct, but we'll get to why soon"
        ostream operator<<(ostream, string) { ... } // returns ostream
        "Perfect example of overloading in C++"
        "Compiler will keep a list of the different function headers"
        "Well documented in <iostream> stdlib"

Declaration Before Use
    In C, we cannot use something before it's declared.
    Same in C++.
        This is problematic for mutual recursion (where two functions are calling each other).

    Look at:
    functions/forwardBad.cc
        Won't compile, because "odd was not declared in this scope".
        To fix this, forward-declare the odd function (header only).
    functions/forwardGood.cc
        bool odd(unsigned int n); // forward declaration (doesn't define the function, but says that it exists).

    forwardBad.cc does not compile because odd is used before it is declared.
    To avoid this, add a forward declaration for odd.
    Saying to the compiler: 'Trust me, you will see a function with this signature.'
        *You can place default arguments in forward declarations.

    Declaration before use, NOT definition before use.
        A declaration is simply an assertion that something exists.
        A definition is the actual implementation.
        *You can declare something as many times as you want, but you can define it only once.
            (There is no benefit to doing multiple declarations, this is just a technicality)

Pointers
    int n = 5;
    int *p = &n; // p is set to the address of n
    cout << p; // prints 10000 (in hex)
    cout << *p; // prints the contents of the thing p points to

    int **pp; // declare a pointer to a pointer to an int
    pp = &p; // 48000
    **pp = 10; // dereferences address 48000 and then 10000. 5 mutates to 10.
        *if(pp) is only false if it doesn't point to an address, is 0 or NULL
__________________
|ADDRESS | STACK |
-----------------|
|        |       |
|10000  n| 5     |
|        |       |
|        |       |
|        |       |
|48000  p| 10000 |
|        |       |
|        |       |
|        |       |
|      pp| 48000 |
|        |       |
|        |       | 
------------------

Arrays
    int a[] = { 1, 2, 4, 8 };
    An array is not a pointer!
    The name of the array is shorthand for the address of the first element of the array.
    a == &a[0]
    *a == a[0]
    *(a + 1) == a[1] // '+' operator accounts for size of typeof(a)
        Recall that this is called "pointer arithmetic"

Structs
    In C:
    struct Node {
        int data;
        struct Node * next; // You don't need to write 'struct' here in C++ (leaving it in is okay, because backwards compatible)
    }; // Don't forget the semicolon! You can technically declare global variables of Node (n1, n2, etc.) before the semicolon, so it is needed!

    In C++:
    struct Node {
        int data;
        Node next;
    }; // Won't compile. ("Can I determine the size of this node in order to allocate memory? Nope. Four bytes plus size of a Node...")
    This worked before, because pointers had a fixed size.

Constants
    const int maxGrade = 100; // Told the compiler that maxGrade has value 100 and it won't change.

    Rule: a const definition must be initialized (can't just say 'const int maxGrade;') "Must be defined when you declare it."

    Constants of other types can also be defined:
    const Node n = {5, NULL}
        Cannot change n. n.data = 10; // Won't work.

    int n = 5;
    const int *p = &n; // p is a pointer to a constant int. [a const-int, haha -JR]
    *I can change p if I want. p=&m; // p is not a constant pointer
    *I cannot, however, use p to change n. *p = 7; // Won't work.
    *I can still directly change n. n = 10; // Works.
    Read backwards: "p is a pointer to an int constant"
    
    int * cons p = &n;
    "p is a constant pointer to an integer"
    *Now, I can't do p = &m;
    *Can do *p = 20;

    const int * const p = &n;
    *Can't do p = &m;
    *Can't do *p = 10;
    *Can still change n directly if it wasn't declared as constant.

Parameter Passing "5-10% QUESTION ON MIDTERM!" -NN
    void increment(int n) {
        n+=1;
    }
    int x=5;
    increment(x);
    cout << x; // prints 5

    Pass by value: a copy of x was created!

    void increment(int *n) {
        *n += 1;
    }
    int x=5;
    increment(&x); // send the address of x
    cout << x; // prints 6.

    *Note that these also count as overloaded functions.

Cliffhanger for next time:
    scanf("%d", &i); // read an int into variable i
    We gave the address of i.
    cin >> i; // reads in a value at i
    These functions are operators (operator>>(istream, int))
    Why can I pass it i, not &i?
    Why not do cin >> (&i); // ?

    "Pass by reference!" -NN
----------------------------------
Lecture 9

Recall cliffhanger from last time:
    scanf("%d", &i);
    cin >> i; // why does this work? (It's not being sent the address of the variable, just the name of the variable)
    Why not use "cin >> (&i);" ?

C++ provides another pointer-like type: References
    int y = 10;
    int &z = y; // z is a reference to y (in C++). Do NOT read this as "the address of z equals y", say "z is a reference to y".

    A reference is like a constant pointer with automatic dereferencing.
        z will always point to y.
        We can write: z = 15; // changes the value of y
            This sets y to 15.
            We no longer have to do *z = 15; // illegal in C++
            No star is needed because it will ALWAYS be automatically dereferenced.

    int *p = &z; // sets p to the address of y
        We set p to the address of z, but since z is a reference to y, we got the address of y.
        A reference has no identity of its own. We tried to assign it a value or get its address, but got y each time.
            It is another name for y.
            Or we can say z is an alias for y.
        Even doing sizeof(z) doesn't always return 4 bytes as expected in C, but the size of y.

    Rules of references:
        1. We cannot leave references uninitialized.
            int &x; // can't do this, since constants/references must be initialized

        2. A reference must be initialized to something that has an address.
            Things that have an address are called 'Lvalues' (this is a compiler term).
            int &x = 5; // can't do this, because 5 is not really an address but a literal value.
            int &y = a + b; // can't do this either, because an expression doesn't technically have an address.

        3. We cannot create a pointer to a reference.
            int &*x = ...; // doesn't work (at least not in the g++ standard)

            3a. We can, however, create a reference to a pointer.
                int *&x = ...; // works

        4. We cannot create a reference to a reference.
            int &&x = ...; // not allowed

            Note: we can still do *p = &z; // sets p to the address of what z is referencing

        5. We cannot create an array of references.
            int &x[3] = {1, 2, 3}; // not allowed
                The name of an array is a pointer to the first address of the array, but &*a is disallowed.

    Use references in function parameters.
        Recall this code from last class:
            void inc (int *n) {
                *n += 1;
            }
            int x = 5;
            inc(&x);
            cout << x; // 6

        Now we will do this with references:
            void inc(int &n) {
                n += 1;
            }
            int x = 5;
            inc(x);
            cout << x; // 6

            In this code, x is being passed by reference. Anything we do to n is actually being done to x.

        Note: We could have a reference to a function (like how we can have a constant pointer to a function).

    Why does "cin >> x" work?
        x is passed as a reference.

        Let's look at the function header for the input operator:
            istream &operator>>(istream &in, int &data) {
                // type of cin is a reference to an istream.
                // "int &data" is the right hand side, it takes the argument by reference.
                // "istream &in", the left hand side, is also being passed by reference. This is so that we can set error flags on "&in" (cin)
                // the reasoning for the return value of "istream &" is so that we aren't returning a copy istream, but rather a reference to the original istream (so it can be chained into another expression)
                // in C, we would have to do all of this with pointers. Automatic dereferencing is the main advantage here.
            }

Suppose I have a struct:
    struct ReallyBig {
        ...;
    };
    int f (ReallyBig rb) { ... }
    f(x); // what happens here?

    A copy of x is going to be made.
        (-) This is expensive to do.
        (-) Also, the changes to rb are not visible to the caller (the piece of code that called f)

    In C, we would send a pointer to ReallyBig.
        (+) This suppresses the copy.
        (+) And changes made in the function are visible to the caller.

    (Passing by Value vs Passing by Reference)

    In C++:
        int g (ReallyBig &rb) { ... }
        g(x);
            (+) This suppresses the copy.
            (+) Changes to rb are visible to the caller.
            (+) Automatic dereferencing.

    What if we want to suppress the copy but we don't want changes made to ReallyBig.
    Send it as a constant reference.
        int h (const ReallyBig &rb) { ... }
        ReallyBig x;
        h(x); // x is passed by reference (no copy is made, so this is efficient), but also can't be modified by h.
        // It's like you only have a read permission, but not a write permission.

    Note: This can be applied to struct Node, struct llist, etc. (The various data structures from CS136)
    Advice: Use pass by const reference for anything bigger than an int.
        int f (int &n) { ... }
        int g (const int &n) { ... }
        f(5); // trying to pass 5 by a reference, but this is illegal because 5 doesn't have an address (5 is not an Lvalue).
            f(y + y); // also doesn't work
        g(5); // compiler WILL allow this, because it is a const and can be stored conveniently. Compiler will remember 5 as long as you don't want to change it.
            g( y + y); // also works, for the same reason (as opposed to doing "int z = y + y; f(z);" every time).


Note: References can't be NULL (we will get back to this in 2 weeks).
"References are not the easiest thing to understand, go over this material and get good at using references." - NN


Dynamic Memory
    In C,
        int size = ...; // size of an array
        int *p = malloc(size * sizeof(int))
        free(p);
    
    Things are not a whole lot better in C++, but we don't have to do the "size * sizeof(int)" calculation.
    C++ Does support malloc() and free(), but DON'T use it (disallowed in this course)!
        instead, use 'new' and 'delete'

        In the linked list example (in C):
            struct Node {
                int data;
                Node *next;
            }

        Let's dynamically create a node, in C++:
            Node *np = new Node;

        'new' is type-aware.
            We don't need to compute the amount of memory we want.
            This is less error-prone. With 'new', you will always get enough memory (or you can receive an error, which we will come back to later).

        When you are done with the node:
            delete np;

        "Do not mix malloc/free with new/delete, that is the worst thing that you can do! Bad things happen. Don't do it. This is what happens when you combine C/C++ codebases." - NN
            delete looks at a book-keeping table that is only updated by new, so it can't recognize malloc'ed things.

    Dynamic Arrays
        Suppose I read in a number and create an array of that size:
            cin >> n;
            int *arr = new int[n]; // dynamically allocated array of size n! new is smart enough to do this!
            // You just tell n that you want n integers, and it uses its type-aware magic to calculate and allocate enough memory.

        Once you are done:
            delete [] arr; // a lot of people forget the '[]', then bad things happen.

            "Some course notes say that 'delete arr' would just delete the first element of the array. This is nonsense, it's really an undefined thing that is compiler-specific. Just remember the '[]'" -NN

        If you allocated memory, it is still your job to deallocate it.

        "And did I mention, don't forget the '[]'!" - NN

        Q: Can you delete something by reference?
        A: "Not sure, don't hold me to this, but I think that would work." - NN

Stack vs Heap Allocation (This should be review)
    You have access to some memory, which is divided into three things:
        program
        stack
        heap

        -----------
        | Program |
        -----------
        | Heap \/ |
        |      \/ |
        |      \/ |
        |      \/ |
        |         |
        |grows dwn|
        -----------
        | Stack ^ |
        |grows up |
        -----------

    Local Variables:
        Allocated on the stack.
        Stack space is reclaimed when local var goes out of scope (a function returns, etc. and the function's local vars are freed).

        Node n; // n is local variable on the stack
        Node *np = new Node; // new Node is on the heap (dynamically allocated) but *np is local, on the stack.

            ...
        |         |
        | Node    |
        |         |
        |         |   (heap)
        -----------
        | np      |   (stack)
        | n       |
        -----------

    Heap-allocated data continues to live even when the pointer goes out of scope.
        That is a memory leak!
        (stack allocated local var of a heap-allocated value goes out of scope when, say, the function that assigned the var returns)
------------------------------------
Lecture 10

Memory Operations / The Preprocessor

    A function that returns a node:

        Node getMeANode() {
            Node n;
            return n;
        }

        This is problematic since node n is allocated in getMeANode's stack frame and must be copied to the caller's frame.
        This is inefficient. (Although it is critical for us to perform that inefficient copy here, to avoid data loss)

    If you instead return a pointer to a stack-allocated variable, really bad things happen.
    e.g.

        Node *getMeANode() {
            Node n;
            return &n;
        }

        This causes a 'dangling pointer'. You should NEVER do this.
        Returning a reference is equally bad, since it's referencing a variable that becomes lost.

    Create the node on the heap:

        Node *getMeANode() {
            Node *np = new Node;
            return np;
        }

        np, the node pointer, gets copied to the callers frame (this is efficient, since pointers are only 4 bytes). This suppresses the copy of the data structure.

        *Caller must keep track of the returned pointer and eventually free the memory.

        main() {
            getMeANode(); // Bad! Doesn't store the returned pointer, so we can't free the memory.
        }


Operator Overloading

    e.g.
        negate(int);
        negate(bool);

        << and >> operators are overloaded (streams and I/O stuff, etc.)

        + is overloaded (arithmetic and string concatenation, etc.)

    General Idea:
        We can give meanings to C++ operators for the types we define.
        e.g.

            struct Vector{
                int x,y;
            }

            We could write an addition function:

                Vector add(vec v1, vec v2) { ... }
                Vector v1 = { ... };
                Vector v2 = { ... };
                Vector v3 = add(v1, v2);

                But this is ugly and awkward to implement.
                    Note that the behaviour behind creating a new vector (v3) from the existing returned vector is complex, and we'll get to this in another lecture.

            Instead, let's overload the + operator:

                operator+(const Vector &v1, const Vector &v2) {
                    Vector v;
                    v.x = v1.x + v2.x;
                    v.y = v1.y + v2.y;
                    return v;
                }

                Since our new header definition is unique, it is a valid overload.
                This can now be used with "V1 + V2" (where V1 and V2 are references).
                    Note that this specific example is overloading a pre-defined C++ operator; we can also do this with our own functions.

            What if we want to do "Vec v4 = 3 * v3" or "Vec v5 = v3 * 3" ? This requires TWO overloads, for each new LHS/RHS behaviour of '*'.

                Vector operator*(const int k, const Vector &r) {
                    // by convention we pass ints by value, since a reference is just 4 bytes anyways.
                    // Remember to use const arguments whenever possible, this can earn marks in the hand-marking of our code.
                    
                    Vector toRet;
                    toRet.x = k*v.x;
                    toRet.y = k*v.y;
                    return toRet;
                }

                Vector operator*(const Vec &r, const int k) {
                    return k*v; // takes advantage of our other definition. Yay!
                }

                Update svn and look at lectures/c++/x-operators/

            Let's also show an overloading of << and >>

                Struct Grade {
                    int theGrade;
                }

                This seems silly, since we could just use an int.
                BUT this lets us tell the compiler we're dealing with our own type, and lets us define overloads specific to grades.
                    Note that we don't talk about typedefs in this course. "We don't talk about that, it would pollute your minds." -NN

                operator<<(ostream &out, const Grade &g) {
                    // we don't want a const ostream, because we will set error flags if something goes wrong, etc. You can never really const an istream.

                    out << g.theGrade << "%";
                    return out; // follows the chaining convention of <<
                    // DON'T return cout here, bad things would happen.
                }

                Note that we could use g now to output a stream to any other streams we can think of.
                    e.g.
                        cout << g;
                        ofstream << g;

                We could define special Grade behaviour in the future. Like how the university caps your grade at 100% (and stops it from dropping below 0 :P)

                istream &operator>>(istream &in, Grade &g) {
                    in >> g.theGrade;
                    if (g.theGrade < 0) g.theGrade = 0;
                    if (g.theGrade > 100) g.theGrade = 100;
                    return in;
                }

                We are assuming that the LHS of the operator is already a Grade number.
                
                cin >> g1 >> g2;
                cin >> g1 >> g2;

Warning: one of the questions (the last one?) in Assignment 3 is very labour-intensive for writing test cases.
    You may want to write a script to do this, or sit two people down and play through to create test cases.

Preprocessor
    
    Source Code --> Preprocessor --> New Source Code --> C++ Compiler

    The preprocessor is the first thing that sees your source code.

    You are already using it.
        #include is a preprocessor directive.
            It says 'find the file specified and paste it right here in the code'.

        e.g.
            #include <iostream>
                This pastes iostream into your code.
                It looks in the standard C++ library (/usr/include/c++/lib ?)

        Alternatively,
            #include "vecotr.cc"
                This looks for files in this directory and pastes it in.

        "This is pretty straightforward stuff, the preprocessor isn't very smart." -NN

    The define directive:
        #define VAR value
            This creates a preprocessor variable and initializes it to a value.
            e.g.
                #define MAX 10
                int array[MAX];

        define is essentially a 'search and replace' function.
        Remember that this happens before the compiler even sees anything.
        The compiler will see "int array[10];"

        This behaviour predates const.
        Now, languages have cosnts.
        It is often encouraged to use built-in language consts instead of #define, but #define is not completely useless.
        This simple search-and-replace strategy is actually quite powerful.

        You can do some really cool/weird stuff with the preprocessor.
        e.g.
            #define ever ;;
            for (ever) {
                // infinite loop :D
            }

        This is fun for making convoluted code. There are ways to output what the preprocessor outputs and play with this.
        We could technically change how C++ code looks completely, if we do "#define while for" etc.
        "PLEASE DON'T EVER DO THIS, THE TAs WILL HATE YOU." -NN
        lol -JR

        Real-world use:
            Defined constants can be used for conditional compilation.
            If we want to write code that works on Unix and Windows, we have problems.
                Unix C++ applications need "int main(){ ... }"
                Windows native applications need "int WinMain(){ ... }"

                We could write two separate codebases...
                OR we could write one codebase that is compiled in two different ways!
                Defined constants are one tool that lets us do this.

                e.g.
                    #define UNIX 1
                    #define WINDOWS 2
                    
                    #define OS UNIX

                    #if OS == UNIX
                     int main(){
                    #elif OS == WINDOWS
                     int WinMain(){
                    #endif

                We are only touching on this very briefly. You will probably see in the industry (on co-op) how it's done.

                Q: I compiled a C++ program with main on Windows. How?
                A: It was probably not a _native_ Windows application.

            We don't want to have to change "#define OS ..." every time!
                We can instead use Compiler Arguments.
                "Compiler arguments to the rescue!" -NN

                define.cc:
                    main() {
                        cout << X << endl;
                    }

                    This wont compile, X is not defined.

                    g++ -DX=15 define.cc
                    ./a.out
                    15

                    It works with compiler arguments!
                    -D is for preprocessor variables
                    We can do
                        g++ -DOS=UNIX ...
                            This sets OS to UNIX

            Note how many different architectures there are nowadays: Win32, Solaris, iOS, etc.

            That will involve a lot of #if #elif usage.

    #define VAR
        This creates VAR, with a value set to the empty string.
    #ifdef VAR
        This condition is true if VAR is defined.
    #ifndef VAR
        This condition is true if VAR isn't defined.

        These can be used for debugging!
        Add a bunch of cout statements that can be removed automatically before submitting to Marmoset!

        Look at lectures/c++/6-preprocess/debug.cc for an example of this.
            DEBUG is not defined in this code, and then there are #ifdef statements.
            g++ -DDEBUG=1 debug.cc
            This will be REALLY useful for the big question on A3 or on our project.
----------------------------------------------------
Lecture 11

Note: Office hours moved to Wednesday 12-1:30 today.

Recall: Preprocessor
    Preprocessor Directives:
        #include
        #define VAR VALUE
            This is useful for conditional compilation.
        #define VAR
            The default VALUE is the empty string.
        #ifndef VAR
    Compile Time Preprocessor Args:
        g++ -DDEBUG
    Examples:
        preprocessor/define.cc
        preprocessor/debug.cc
    #if 0
        ...
        Code not forwarded to the compiler.
        Fancy way to comment things out!
        ...
    #endif

Separate Compilation
    Break our implementation into:
        1. Interface files (.h files)
            Contains type definitions (struct Node, etc.), function headers.
        2. Implementation file (.cc file)
            Contains implementation of functions.

    separate/example1:
    vector.h:
        struct Vec {
            int x;
            int y;
        }

        Vec operator+( ... );

    main.cc:
        #include "vector.h"
            // All the compiler needs to know is that an implementation for vector exists.

    vector.cc:
        #include "vector.h"
        Vec operator+( ... ) { ... }
            // Sees the type def for Vec in vector.h

    This separation is important in case someone wants to change the definition of "struct Vec". Having it defined in only one place is important.

    To compile:
        g++ main.cc vector.cc
        g++ *.cc
            This only works if your directory is well-organized.

    Note that .h files aren't to be compiled. Never compile header files, they are meant to be included (and then compiled) in .cc files.
        Compiling a .h will result in a .h.gch, a compiler header that takes priority over your other .h files. This will cause problems.
    Note: Never include .cc files.

    If you are building a huge video game and change one character, you don't want to have to change that character's definition all over the project.
    Separate compilation is about being able to compile individual pieces of a program and then combine them.
        This also helps for debugging. You can compile individual .cc files for debugging output instead of comiling the whole project.
        Error "ld": Linker error. Valid C++, but no defined main function is seen by g++.
            We can't compile separate pieces by default. g++ tries to compile AND link and produce an executable by default.
            g++ -c vector.cc
                This works, and outputs vector.o by default.
            g++ main.cc
            g++ vector.o main.o
            ./a.out

        .o file is an object file.
            Contains:
                Binary for compiled code.
                Information about what is needed to link (what is available and what is missing).

        vector.o:
            Says we need operator+ implementation, and we need main.

        main.o:
            Says we have main, and we need operator+ implementation for Vec.

        Invoke the linker by giving all of the object files:
            g++ vector.o main.o
                Here, the linker is like a match-maker. It makes sure the needs of each object is met.

            This is separate compilation. If main.cc is changed, simply recompile main.cc and compile using the new main.o.

    Dealing with Global Variables when Using Separate Compilation:
        File abc.h:
            int globalVar; // declaration AND definition.
                Any .cc file that includes abc.h has a globalVar variable.
                When you compile this .cc file, the .o file will say "I have a variable called globalVar".
                    The linker will recognize all of the .cc files including abc.h saying that they have globalVar variable.
                    Linker will complain: You cannot have a var with the same name.

        Solution:
            1. Move definition to abc.cc:
                int globalVar;
                // Since we never include .cc files, abc.o will be the only one with a definition of globalVar
            2. We need a way to declare but not define this elsewhere. In abc.h:
                extern int globalVar; // "Somebody will define globalVar somewhere."
                // "Forward declaration of vector.h"

        See separate/example2/

    separate/example3/
        g++ *.cc
        Compiler error: redefinition of 'struct Vec'.
            Both linearAlg.h and linearAlg.h contain "#include vector.h".
            linAlg.cc includes both of these .h files, so it sees two definitions of vec.

        To fix this:
            1. Don't include vector.h twice. This is hard to keep track of though.
            This is the very reason why we talked about the preprocessor!

            2. Use include guards.
                vector.h:
                    #ifndef __VECTOR_H__
                    #define __VECTOR_H__

                    struct Vec { ... };
                    Vec operator+( ... ){ ... };
                    #endif

                    This prevents the inclusion of the same piece of code multiple times.
                
                Advice: Always have include guards in .h files.
                    In CS246: This will give us handmarking marks!
                    In real world: This is good practice!
                More advice: Never use "using namespace std;" in header files. All .cc files that include that .h would be forced to use that namespace!
                    Always refer to cout as std::cout, cin as std::cin, string as std::string, etc.
                    Maybe somebody wants to implement a String type in their .cc file.
                    We CAN use the namespace in our implementation.

Classes
    The big idea behind Object-Oriented Programming (OOP) is that you can put functions inside of structs.
    e.g.
        Struct Student {
            int assns, mt, final;
            float grade () {
                return 0.4*assn + 0.2*mt + 0.4*final;
            }
        };

        This is a struct with a function in it. A class!

        Create the student:
            Student s = {80, 55, 70};
        Call the grade function:
            s.grade();

            We are calling a function that is defined inside a struct.

    A class is a struct that can contain functions.
        All C++ structs can contain functions, so they are all classes!
        "class" keyword exists: We will talk about this later.
        For now, when we say "class", we are talking about a struct with functions.

    An instance of a class is called an object.
        Above, 's' is the object and 'Student' is the class.

    A function residing insed a class is called a member function or a method.

    In grade() above, we use FIELDS of the struct instead of local variables.
        This method is using variable names it has not declared.
        This structure definition does not reserve any memory, it just says what it means to be a student.
        What do assns, mt, final refer to in grade()?
            They refer to the assns, mt, and final for the object on which grade was called.
            They are the fields of the current object.
                Student s = {80,55,70};
                s.grade(); // assn, mt, final marks of s

                Student billy = {80, 70, 90};
                billy.grade(); // billy's grades are used
--------------------------------------------------
Lecture 12

Recall from last time:
    Struct Student {
        int assns, mt, final;
        float grade() {
            return assns*0.4 + mt*0.2 + final*0.4;
        }
    }

    Student s = {80,55,70}; // c-style initialization
    s.grade();


Function vs Method
    Method has an additional hidden parameter called "this".
    "this" is a pointer to the object on which the method was called.

    Inside grade,
        this == &s
        *this == s

    In the grade() code above,
        this->assns*0.4 +
        this->mt*0.2 +
        this->final*0.4;

        This is equivalent to the previous example, since we don't explicitly need to use "this".
        Sometimes it is useful to disambiguate between global variables and fields, etc.

Constructors
    Now:
        Student billy = {90, 80, 70};
            90, 80, 70 are compile-time constants. This is limited and unrestricted (we could give a mark >100).

    It would be nice to be able to do arbitrary computation for initializing an object.
    We can implement constructors, which are methods used to initialize objects.

    Struct Student {
        int assns, mt, final;
        float grade() { ... };

        Student(int assns, int mt, int final) { // A constructor! These must be the same name as the class, and can't specify any other return type.
            this->assns = assns;
            this->mt = mt;
            this->final = final;
        }
    };

    "this" came in handy here to differentiate between constructor arguments and the object's fields.
    Note that we can perform computations/checks before assigning the field values.

    We can call the constructor with the following (both of these are EXACTLY the same):
        Student billy(80, 55, 70);
        Student billy = Student(80, 55, 70);
            
        Both of these allocate objects on the stack.
        If we want billy to reside on the heap:
            Student billy = new Student(80, 55, 70);
                The above line is incorrect. "new" always returns a pointer, not an object.
            Fixed:
                Student *billyPointer = new Student(80, 55, 70);
                ...
                delete billyPointer; // "Billy is now gone. I feel like God." -NN

    We have used constructors already in our code: "iStringStream ss(s)".

    Advantages of Constructors:
        (+) arbitrary computation (they are functions, so we can do anything)
        (+) default arguments
        (+) overloading

    e.g.
        Struct Student {
            int assns, mt, final;
            ...
            Student(int assns=0, int mt=0, int final=0) {
                this->assns = assns;
                this->mt = mt;
                this->final = final;
            }
        };           // Don't forget the semicolon!

        The above can take 3, 2, 1, or 0 arguments.
            Student s(60, 70, 80);
            Student s1(60,70); // final = 0
            Student s2(60); // mt = final = 0

        You would think you would utilize all three default arguments with the following:
            Student s3(); // incorrect
        But wait! That looks exactly like a declaration, and C++ would treat it as such.
        Instead, we do:
            Student s3; // assns = mt = final = 0

    Every class comes with a default (0-argument) constructor that calls default (0-argument) constructors on fields who have constructors.
        e.g. String class has a default (0-argument) constructor.
        e.g. Struct Vec { int x, y; }; // also comes with a default constructor
             Vec v; // calls the default constructor! x and y are uninitialized though.

        Base types and primitive types (e.g. int) are left uninitialized, but other objects are initialized (say, if we had a Student inside Vec).

        The default constructor goes away as soon as you write a constructor of your own.
        e.g.
            Struct Vec {
                int x, y;
                Vec(int x, int y) {
                    this->x = x;
                    this->y = y;
                }
            };

            Now, calling "Vec v;" would not compile because our default (0-argument) constructor has gone away.
            Calling "Vec v(1, 2);" is how we need to call this constructor.

        As soon as you write a constructor, you also lose c-style initialization ("Student s = {60, 70, 80};").
        As soon as we write a constructor, C++ knows we are  treating these as objects, so it gets rid of the structure behaviour inherited from C.

    Odd technical example:
        struct MyStruct {
            const int myConst;
            int &myref;
        }

        The above should look strange, because the above variables would normally have to be initialized.
        However, the above is correct.
        Field initializers are not allowed here in the definition.

        struct MyStruct {
            const int myConst = 5; // not allowed
            int &myref = m; // not allowed
        }

        We can't do this. What if we want each object to have a constant field that we define during initialization? The above would contradict our ability to do that.
        You cannot initialize constants/references in the constructor body, either! At that point, it's too late (see below).

        Potential midterm question: What happens when an object is created?
            1. Space is allocated (on the stack or on the heap, depending on how it's created).
            2. Fields are initialized and default constructors (if present) are created.
            3. The constructor body runs.

        To fix this initialization problem, we will hijack step 2:
            Member Initialization List
                Note: We can only do this for a constructor, not on any other method in the class.

                Struct MyStruct {
                    const int myConst;
                    int &myRef;
                    MyStruct(int c, int &r):       // Woah!
                        myConst(c), mrRef(r) {     // Done with member initialization list, continue with constructor body.
                            ...
                        }
                };

                Fields are initialized in declaration order, irrespective of the order in the member initialization list.
                Step 2 above no longer executes. We have circumvented it.
                We can use MIL whenever we write a constructor.
                e.g.
                    struct Student {
                        int assns, mt, final;
                        Student(int assns, int mt, int final)
                            : assns(assns), mid(mid), final(final) {} // Valid!
                    };

                    "assns(assns)" is the same as writing "this->assns = assns". Inside the MIL, we guaruntee that the names used are fields. The regular scope of variables also applies.

                Advantages of the MIL:
                    (+) only way to initialize constants/references
                    (+) can use the same name for fields/parameters (no need to type "this->")
                    (+) can be more efficient (we don't initialize the default values then overwrite them in the constructor body, only 1 assigment per field)

                Let's say we have a Vec inside the MIL:
                    struct Student {
                        int assns, mt, final;
                        Vec V;
                        Student(int assns, int mt, int final)
                            : assns(assns), mid(mid), final(final) {} // Valid!
                    };

                    Above, the default Vec constructor will be called if we don't put it in the MIL.
                        "We can call non-default constructors ourselves, but we will discuss that later in the term." -NN

    Copy Constructors and Shallow Copy vs Deep Copy
        Consider the following:
            Student billy(60, 70, 80);
            Student bobby = billy;
        How does this initialization occur?
        We are constructing an object as a copy of another.
        We are calling the Copy Constructor.
            It takes one parameter which is a constant reference to the type of the class.
            You get a default copy constructor for free. It does a field-for-field copy.
            Note: We get two other things for free - Destructor and Copy Assignment Operator (we will discuss these on Thursday).

            The default copy constructor looks like this:
                struct Student {
                    Student(const Student &other)
                        : assns(other.assns),
                          mt(other.mt),
                          final(other.final) {}
                };

            Rule of thumb: Any time dynamic memory comes into play, we must write our own constructor/destructor/copy-constructor.
            e.g.
                Struct Node {
                    int data;
                    Node *next;
                    Node(int data, Node *next): data(data), next(next) {} // constructor
                    Node(const Node &other): data(other.data), next(other.next) {} // what our default copy constructor looks like (only a "shallow copy")
                };

                Node *n = new Node(1, new Node(2, new Node(3, NULL)));
                Node m = *n;
                Node *np = new Node(*n);
                Let's look at the memory here, in a linked-list style pointer diagram (n, m, np are on the stack, things created with new are on the heap):

                    n[  ]->[ 1 ][  ]->[ 2 ][  ]->[ 3 ][ \ ]
                             ^          ^
                            /            |    
                    m[ 1 ][  ]          |
                                        |
                    np[  ]-->[ 1 ][  ] -'

                    Not three copies of the entire list! It's just a shallow copy!
                    Only one new Node pointer is created. If the original list (n) gets deleted, m and np will not point to valid blocks of memory!

            We need to perform a "deep copy" to create an entirely new linked list.
            Deep copy constructor:
                Node(const Node &other):
                    data(other.data),
                    next( other.next ? new Node(*other.next) : NULL)
                    {}

                If other.next isn't NULL, point to the next Node.
                Node(*other.next) is a recursive call to the copy constructor.

        Lots of excellent examples in classes/constructor/
        "VERY GOOD TO STUDY FOR THE MIDTERM!" -NN
-------------------------------------------------
Lecture 13

"Content up to and including this lecture will be covered on the midterm, but not the next lecture. Study all of this!" -NN

More notes on copy contructors:
    Places where a copy constructor is called:
        When an object is constructed as a copy of another.
        When we pass an object by value (and a copy of it is created for the function being called).
        When we return an object from a function.

    A copy constructor takes its only parameter by const reference. The other object isn't changed.
        Note that it has to be a reference, because to pass in an object by value you must run a copy constructor! This would create an infinite loop here.

Recall the four things that we get for free:
    Default constructor
    Default copy constructor (only does shallow copies)
    Destructor
    Assignment creator

Destructors
    When an object is destroyed, a method called the destructor runs.
        A stack allocated object is destroyed when it goes out of scope.
        A heap allocated object is destroyed when you call delete on its pointer.

    A destructor:
        Takes no arguments.
        Has the same name as the class, prefixed with a tilde (~).
    A class only has one destructor.
    There is a default destructor. It automatically calls destructors on any fields which are objects.
        Note that base types and pointers to objects don't have destructors.
            It's important that pointers don't have destructors by default. If they are pointing to something important, we may need a custom destructor.
                e.g.
                    Node *np = new Node(1, new Node(2, new Node(3, NULL)));

                    stack    --------- heap ---------

                     np --->[1][ ]--->[2][ ]--->[3][/]

                    If there is no call to delete:
                        np, being stack allocated, is reclaimed. No destructor runs!
                        Three nodes are leaked!
                    If we call delete on np:
                        Called destructor on [1][ ]--->
                            The default destructor runs.
                        No destructors for fields!
                        Two nodes are leaked!

                    We need a custom destructor.

    Custom destructor example:
        struct Node {
            ...

            ~Node(){
                delete next;
            }
        };

        Now, calling delete on np:
            This calls delete on the next Node(s) recursively and stops appropriately when the end (NULL pointer) is encountered.
            Note that calling "delete NULL;" won't create any error, delete is smart enough to not do anything.
            The first part is deleted because this whole recursive delete process is started with "delete np;".

"Another thing I'm squeezing in today... you can guess why." -NN ;)

Recall separate compilation:
    Interface (.h) files: type definitions and function headers.
    Implementation (.cc) files: implementation of functions.

    This approach is now problematic because we are implementing method definitions inside class declarations, so we would have implementations in header files!
    Now we will stop implementing methods inside class definitions.
    Instead:
        For a class, give method headers in the .h file.
            e.g. (.h file):
               struct Node {
                    ...
                    ~Node();
                    Node(int data, Node *next);
                };

        We will put the implentation of ~Node in a .cc file.
            How does the compiler know that ~Node belongs to the Node class?
                We use the scope resolution operator.
                In the .cc file:

                    Node::~Node() {
                        std::cout << "Destructor called" << std::endl;
                        delete next;
                    }

                    This defines ~Node in the scope of Node.
                    "We still always need include guards in our .h files. You will lose marks if we don't." -NN
                    See /lectures/c++/8-classes/separate/

                Use Node:: in .cc files.
                    This is called the scope resolution operator.
                    Node::getData()
                        getData in the context (scope) of the node class.

"Now, perhaps the most technical of the four methods you get by default." -NN
"We will show two ways this is done. Study both ways as much as you can." -NN (hint hint)

Assignment Operator
    Student bobby(60, 70, 80);
    Student billy = bobby; // copy constructor
    Student jane; // zero-argument constructor
    jane = bobby; // jane already exists! We are re-assigning its fields to be a copy of bobby.
         ^assignment operator (=)

    We get a default assignment operator:
        Default "operator=" (assignment operator) does a field-for-field copy.
        For Student, the default operator= works fine!

    We must implement our own assignment operator if dynamic memory is involved.
        struct Node {
            ...
            Node &operator=(const Node &other) { // other is the right hand side of the assignment
                // The return type is a Node reference so that cascading works (we have seen this reasoning before).
                // Remember that this is NOT a constructor.

                // Default implementation (only a shallow copy):
                //     data = other.data;
                //     next = other.next;
                //     return *this; // *this is the object

                // To get a deep copy, we must create new Nodes.
                data = other.data;
                // next = new Node(*other.next); // Call to copy constructor (must already be implemented). This can cause errors if we encounter a NULL pointer.

                next = other.next ? new Node(*other.next) : 0; // 0 is equivalent to typing NULL
            }
        }
        "If your copy constructor and assignment operator look very similar, you have done something wrong." -NN
        Don't overwrite the next pointer straight away, that creates a memory leak!

            Node &operator=(const Node &other){
                data = other.data;
                delete next;
                next = other.next ? new Node(*other.next) : NULL;
                return *this;
            }

            This is still wrong! It breaks with self-assignment:

                Node n(1, new Node(2, new Node(3, NULL)));
                n = n;

                Node &operator=(const Node &other){
                    n.data = n.data;
                    delete n.next;
                    n.next = n.next ? new Node(*n.next) : NULL; // now this behaviour is undefined, since n.next has been deleted!
                    return *this;
                }

           We must ALWAYS check for self assignment (check if other is equal to this).
           Note that we only have this problem in the assignment operator, because we could only be referencing the same object here.

            Node &operator=(const Node &other){
                if (this == &other) return *this;
                data = other.data;
                delete next;
                next = other.next ? new Node(*other.next) : NULL;
                return *this;
            }

            For CS246, we are done. Lots of technical details here, be sure to study it.

            In the industry (we don't need to know this) your code has to be more robust.
                What happens if we run out of memory when we try creating new Node?
                If the call to new fails, code execution stops for this method, the stack is unwound.
                next is now a dangling pointer. It has not been set to NULL, nor does it point to anything.
                To fix this problem, delay the delete until after the next Node is created.
                    This is called a delayed delete:
                        Node &operator=(const Node &other){
                            if (this == &other) return *this;
                            data = other.data;
                            Node *tmp = next;
                            next = other.next ? new Node(*other.next) : NULL;
                            delete *tmp
                            return *this;
                        }

                "We don't need to do delayed delete on the exam, but we must check for NULL, return *this, etc." -NN

        Another, easier to understand implementation of an assignment operator:
            Copy and Swap Idiom

                struct Node{
                    ...
                    void swap(Node &other){ // NOT a const reference
                        // Swap all the fields of a given object.

                        int tdata = data;
                        data = other.data;
                        other.data = tdata;

                        Node *tnext = next;
                        next = other.next;
                        other.next = tnext;
                    }
                    Node &operator=(const Node &other){
                        Node tmp = other; // calls copy constructor
                        swap(tmp);
                        return *this;
                    }
                }

                Notice that we never used delete. We assigned tmp to be a copy of other ON THE STACK.
                Note that this requires a functioning copy constructor.
                "Node tmp = other;" would call a deep copy constructor, so no recursion is neeed in the assignment operator.
                Before returning *this, "this" has the needed fields, and tmp has the old fields.
                This also relies on having a functioning destructor, because it will be called on tmp when it goes out of scope.

Summary of today's lecture and yesterday's lecture:
    Rule of 3
        If you need to implement a custom version of the copy constructor or the destructor or the assignment operator,
        then you usually need to implement all three.

Office hours 2-4:30pm today. 10 minute limit per student if it's busy.
----------------------------------------------
Lecture 14

Explicit
    struct Node {
        int data;
        Node *next;
        Node(int data): data(data), next(0) {}
    };

    Node n(4); // legal
    Node n = 4; // also legal

    We have created an implicit conversion from an int to a Node.
    (These implicit conversions are only valid for single argument constructors.)

    This lets us do:
        string abc = "hello";

    These are silent conversions, with no error messages.

    int foo(Node n);
    Node x ... ;
    f(x); // works
    f(4); // also works

    To disable the conversion, use the keyword explicit.
        struct Node {
            explicit Node(int data): ...
        };
        Node n = 4; // raises compiler error
     
Arrays of Objects
    Exactly the same as arrays of structs or arrays of base types.
    Not tested on the exam: the constructors available to us if we want to create an array of objects.
    struct Vec {
        int x,y;
        Vec(int x, int y): x(x), y(y){}
    };
    Vec vectors[10]; // won't compile
    Vec *vectors = new Vec[10]; // won't compile either
    We don't have a constructor that takes zero arguments!
    We don't know how to initialize vectors in an array without a zero argument constructor.
    OPTION 1: Provide a zero argument constructor.
        Vec(int x = 0, int y = 0);
    OPTION 2 (On the stack):
        Explicitly call the two argument constructor for every element.
            Vec vectors[3] = {Vec(1,2), Vec(2,3), Vec(3,4)};
    OPTION 3:
        On the heap or stack, create an array of pointers to vectors.
        Vec *vectors[10]; // array of 10 Vec pointers on the stack.
            Note: To initialize these to NULL, loop through and set them to NULL explicitly.
        Vec **vectors = new Vec *[10]; // on the heap
            Note: Not a double pointer, "Vec *" elements. Same syntax as "const char *".

Member Functions vs Standalone Functions
    (Inside a class vs outside a class)

    Note: operator= is always a member function.
    When an operator (including operator=) is defined as amember function, the left hand side argument is the "this" pointer.
        n1 = n2;
        operator=(const Node &other)
        "this" is n1
        other is n2
        Think about it as "n1.operator=(n2)"

    struct Vec {
        int x,y;
        operator+(const Vec &v2) { // our signature has changed, since our standalone operator+ had two arguments
            Vec v;
            v.x = x + v2.x;
            v.y = y + v2.y;
            return v; // remember that the copy constructor is called here
        }
    };

    Alternate implementation:
    operator+(const Vec &v2) {
        Vec v(x + v2.x, y + v2.y); // relies on two argument constructor
        return v;
    }

    operator= HAS TO be inside, as a member function

    .h file:
    Vec Vec::operator*(const int k) {
        return VEc(x * k, y * k);
    }
    "Not a standalone function, implementing as a member function of Vec."
    v1 * k; // v1 is "this", k is argument

    What if we do k * v1?
    Left hand side k is an integer, not a vector! You can't implement "k * v1" as a member function, it has to be standalone.
    e.g.
        Vec operator*(const int k, const Vec &v) {
            return v * k;
        }

    Writing the output operator as a method:
        struct Vec {
            operator<<(ostream &out){
                out << x << y << endl;
                return out;
            }
        }
        Correct usage:
            Vec v;
            v << cout;
            (LHS "this" must always be a vector.)
            Cascading can cause big issues here:
                v2 << (v1 << cout)
            This is ugly. DON'T DO IT.
        Moral of the story:
            Input and output operators are always implemented as standalone functions.
            Define << and >> as standalone functions.

    You must implement the following operators as member functions (methods):
        operator=
            Note: We get an operator= for free, so a standalone function would be redundant.
            This makes sense, since you would have to overwrite the default operator= method to define your own behaviour.
        operator[] - makes your class act as an array, as in string[0] == 'N'
        operator* - makes your object act as a pointer
        operator() - act as a function
        operatorT() - define an implicit conversion to T
            e.g. "operatorVoid*"

        "Why? Ask Bjarne. He's the C++ God." -NN

Const is back!
    int f(const Node &n); // says that we can't modify n's fields
    Can you call methods on const objects?
        Yes, as long as the method promises not to change the fields.

    struct Student {
        int assns, mid, final;
        float grade() {
            return assns * 0.4 +
            mid * 0.2 +
            final * 0.4;
        }
    }
    const Student s(...);
    s.grade(); // Can we do this? No. It hasn't promised not to change the fields.
    To make this promise not to change fields, add const after the argument list.
    float grade() const { ... }

    Won't compile:
        struct Student {
            int assns, mid, final;
            int methodCalls;
            float grade() const {
                methodCalls++;
                return ...
            }
        }
    C++ to the rescue with the "mutable" keywords:
        struct Student {
            int assns, mid, final;
            mutable int methodCalls;
            float grade() const {
                methodCalls++;
                return ...
            }
        }

        "I bet we'll eventually have a const mutable. Then a mutable const mutable. Programmers are never happy. From a theoretical standpoint, mutable is bad. But I guess it's useful" -NN

    In summary:
        If you have constant objects, they can call constant methods.
        Non-constant objects can also call const methods.

Static
    In C:
        Made variable non-extern (set scope as "local").
        Also did other things.
    In C++:
        Can have static fields:
            If a field is declared as static, then it is associated with the class and not any specific object.
            In other words, only one field in memory for all objects of the class.
            In contrast to non-static fields, where objects each have their own memory.

            struct Student {
                static int numInstances;
                struct int(...) {
                    ++numInstances;
                }
            };
            How is numInstances initialized?
                Is it initialized to zero by the compiler? No.
                We don't have space to define numInstances in the class definition, we have only declared it here.
                We need a defninition of numInstances!
                numInstances must be defined separately (a file external to the declaration).
                    In .cc file:
                        int Student::numInstances; // defined, not initialized (automatically initialized to default of primitive object, in this case 0)
                        OR, initialize it yourself:
                        int Student::numInstances = 0; // definition and initialization

    Static Member Functions
        Functions don't depend on any object of the class.
        You don't call these on objects of the class.
        There is no "this" parameter.
        Note: Calling static member functions "static methods" is technically incorrect, since a method is part of an object. However, "static method" is a commonly used/understood phrase.

        Restrictions on static methods:
            Static methods can only call other static methods and can only access static fields.
                struct Student {
                    static int numInstances;
                    static void print() {
                        cout << numInstances;
                    }
                }
            int main () {
                student ...
                ...
                Student::print(); // proper way
                billy.print(); // also works, but less accurate.
            }
------------------------------------------
Lecture 15

Singleton Pattern, Encapsulation

Design Pattern: If you have THIS situation then THIS programming technique might help

Singleton Pattern:
    Restrict class to create only one instance of an object.
        e.g. Only one connection to a database.
        e.g. Only one error log.
    On the assignment: Only creating one scoreboard (A3Q4).

    We have a class c and we want only one instance (object) to be created (throughout the life of the program).
        e.g. Fincances
            Wallet: only have one wallet (singleton)
            Expense: many expenses all accessing the same wallet

            wallet.h:
                struct Wallet {
                    static Wallet *sinstance; // No pointer? Won't compile.
                    static Wallet *getInstance();
                    Wallet();
                    int money;
                    void addMoney(int amount);
                };

                To make sure only one Wallet object is created, make use of static fields (only one, associated with the entire class).
                Note: there is no restriction on the ordering of fields/methods within a class.
                Note: static methods are class-wide, non-static methods are called on instances.

            wallet.cc:
                Wallet * Wallet::instance = 0; // 0 == NULL
                Wallet * Wallet::getInstance() {
                    if(!instance) {
                        instance = new Wallet;
                        atexit(cleanup)
                    }
                    return instance;
                }
                Wallet::Wallet() : money(0) {}
                void Wallet::addMoney(int amount){
                    money += amount;
                }
                static void::cleanup(){
                    cout << "called cleanup";
                    delete instance;
                }

            expense.h:
                struct Expense {
                    const std::string desc;
                    const int amount;
                    Wallet *wallet;
                    Expense(std::string desc, int amount);
                    void pay();
                };
            expense.cc:
                Expense::Expense(string desc, int amount)
                    : desc(desc), amount(amount) {
                        wallet = Wallet::getinstance();
                }
                void Expense::Pay() {
                    wallet->addMoney(-amount);
                    cout << "Paying " << amount < <endl;
                }

            see lectures/se/singleton/class-demo
                (Note that the first Expense instance created creates the first and only Wallet instance)
                "This is word for word what our Scoreboard class will look like in A3Q4." -NN
                "Have two instances of the Player class to handle the two players." -NN

            Problem:
                We create a wallet on the heap, and never delete it. That's a memory leak.
                We could delete the wallet at exit, but there are programs that keep running outside of main.
                Wallet may need to be referenced before or after the main function, so we can't always call the destructor ourselves in main.
                Can't rely on end of main function to delete instance (Wallet).

            Solution:
                Borrow function from C:
                    atexit(functionName); // <cstdlib>
                    // functionName function should have no arguments and a void return type.
                Can stack up multiple calls to atexit.
                    Functions will execute in last-in-first-out style, like a stack.
                    Inside Wallet.cc:
                        static void::cleanup(){
                            cout << "called cleanup";
                            delete instance;
                        }

                        // above:
                        instance = new Wallet;
                        atexit(cleanup);

            To check that memory is cleaned up on the heap, use valgrind.

Tool: Valgrind
    valgrind ./a.out --- // >> "All heap blocks freed." (for this particular input)

Encapsulation
    "Make your object a black box and only expose certain features." -NN
    Keep certain implementation details hidden.
    Object appears as a black box with some exposed interface which can be used by users.

    e.g.
        struct Vec {
            Vec (int x, int y) : x(x), y(y) {}
            private :
                int x,y;
            public:
                Vec operator+...;
        };

    x and y are now private.
        int main() {
            Vec v(1, 2); // Allowed (default visibility in struct is public).
            v.x = 5; // Not allowed.
        }
        Default visibility inside of a struct is public (if you don't do "private:").
        Private methods can be called from within the class. So with singleton, make the constructor private and call it with getInstance().


    class keyword
        
        \o/ - Huzzah!
         |
        / \

        Default visibility should be private, so that it makes the programmer think before making something public.
        C++ introduces the "class" keyword. Default visibility is private.

        class Vec {
            int x, y;
            public:
                Vec(int x, int y);
                operator+...;
        };

        Always keep fields private (these are just implementation details).
        Constructors, destructors, etc. default to PUBLIC still.

        With private fields you can provide users with the field values using public 'getters'.
            e.g.
                int Vec::getX() { return x; }
                int Vec::getY() { return y; }

        To allow others to change values of private fields, you can provide public 'setters'.
            e.g.
                void Vec::setX(int _x) { x = _x; }
                void Vec::setY(int _y) { y = _y; }

            Inside setters, you can still run code to, say, check if the new values are acceptable. This can maintain/enforce class invariants.

    Hide implementation details (including fields) so that you can:
        - Maintain class invariants.
        - Change implementation in the future.

    Vec: fields are private.
    Suppose we don't want to expose get and set methods, but we want to implement the output operator.
        Answer: next lecture.
----------------------------------------------------------
I missed this lecture.
Notes typed by Anna Lorimer, revised by me for formatting:
----------------------------------------------------------
Lecture 16: October 30 2014

Announcements:
    Good News: 
        Nomair has candy today. AND HE'S GONNA GET US TIMBITS SOMETIME (to bribe us to come to class).
        He needs people to recommend music for him to play at the beginning of class (NOT top 40 in the last 5 years).
    Bad News:
        Midterms have been marked.
        The Average: 59%
        But it was harder than last term (the average last term was 62%).

Recall: Last time we discussed the class keyword
    Vec with private x,y fields and no public get or set methods. Implement operator<<. 

    ostream &operator<<(ostream &out, const Vec &v) {
        cout<<v.x<<" "<<v.y;
        return out;
    }

    This can be implemented this way because x and y are private. 
    So we want to provide encapsulation, be we also want to be able to make an exception
        The 'friend' keyword (this is on assignment 4).

    Note: Friend is useful for input and output operators.

    class Vec {
        int x,y; // private by default
        public:
            friend std::ostream &operator<<(std::ostream &, const Vec &); // 'operator<<' is NOT a method. 
    }
    
    What this says is: "this is what it means to be a vector and operator<< is my friend so it has access to all my private parts".
    Once the 'friend' keyword has been added, the implementation above compiles 

    There is no friendship qualifier that gives ONLY read access.
        By adding 'friend' you are breaking encapsulation. So if that friend is an ass they might break everything.  

    You can make a class a friend of another class. 

    Advice: "Unlike real life, have as few friends as possible".
        Because it does break encapsulation which was the whole point behind the 'private' keyword.

    Note: Public methods can access private fields.

System Modelling:

    Even with limited knowledge of C++ we can design relatively complex programs
    We're better off designing something and them implementing it.

    When designing: 
        1. What are the abstractions in my program? 
            -a.k.a What classes will I have? 
        2. Relationship between classes 

    We will discuss the difference kinds of relationships 

    There are formal methods to specify the design of a system
        We will use UML (Unified Modelling Language)

    UML is an amalgatmation of a bunch of standards (it's huuuuge) 

    A UML class is a box:

    -----------------
    |Vec            | ->name of class (NOT OPTIONAL)
    -----------------
    | - x: Integer  | ->fields (optional)
    | + y: Integer  |        not all fields need to be written (- == private, + == private)
    -----------------
    |  - setX       | -> methods (optional)
    |  + getX       |
    -----------------

    Relationship 1: Composition
 
        class Vec {
            int x,y,z; // private fields
            public:
            Vec(int x, int y, int z): x(x), y(y), z(z) {}
        };

        Let's say we want to define what a plane is. 

        class Plane  {
            Vec v1,v2;
        };

        This is composition because you are embedding objects inside of objects

        Note: If in your main code you do
            main () {
                Plane P; 
            }
            this won't compile because the default constructor for Plane will run, this runs the default construct for Vec which has been overwritten. 

    To fix this:
        Option 1: Provide a default constructor (meh)
        Option 2: Create a constructor for Plane which calls the non-default constructor for Vec. (YEH)

        e.g. 
            class Plane {
                Vec v1,v2;
                public:
                Plane(): v1(2,3,4), v2(5,6,7) {} // now Plane P; in main compiles 
            }                  \      /
                                \    /
                                 \  /
                      calls 3 parameter constructor


    Back to composition:

    Composition is embeding an obejct (e.g. Vec) inside another object (e.g. Plane)
    This is also called an "owns a " relationship  (as in Plane owns Vector)

    When is this useful? Some guidelines: 
        If A "owns a" B, then B has no existence outside A 
        If A is destroyed B is destroyed 
        If A is copied, B is copied

        e.g. A cars "owns a " wheels 

    "owns a" in UML:

    -----------          -------------
    | Plane    | ->     | Vec       | (delta is a shaded diamond)
    ------------         -------------
    | ...      |         | -x        |
    ------------         | -y        |
                         | -z        |
                         -------------

    Relationship 2: Agregation
        
        e.g. A catalog has car parts. These parts exist outside a catalog; destroying or copying catalog has no effect on parts.

    This is a "has a" relationship 

    Agregation is implemented through using pointers to objects  inside another object

    e.g. Pond "has a" ducks.
        
        class Pond {
            Duck *ducks[20];
        };


    A key challenge is deciding between agregation an composition

    Agregation in UML:

    ------------        -------------
    | Pond     | ->    | Duck      | (delta is a hollow diamond)
    ------------        -------------
    | ...      |        | -x        |
    ------------         -------------

    Relationship 3: Inheritance 

    All code is available in the repository

    e.g. Track my collection of books (c++/inheritance/example1)
        
        class Book {
            string title, author;
            int numPages;
            public:
                Book(string title, string author, int numPages) {...}
        };

        What if we want to also partition our books into textbooks, comic book etc. and keep unique information for each type of book? 

        class TextBooks {
            string title, author;
            int numPages;
            string topic;
        };

        class ComicBooks {
            string title, author;
            int numPages;
            string protag; //progtagoniast of comic books
        };

        Now we can represent general books, textbooks and comic books. We want an array(collection), but we don't want 3 different arrays...

    There are two ways we can represent 3 different types in an array
        In C:
            Option 1: 'union'. 
                    union Booktype{ 
                            Book *b;
                            TextBook *tb;        ]->creates an array of booktypes
                            ComicBook *cb;
                    }

                    BookType myBooks[20];
            
                this is a bad option because you need to track what each element contains 

            Option 2: Array of void*
                but you still need to track extra information
                also, you could place a types that isn't a book 
                this is acutally worse than using union

    We can use inheritance to create a book hierarchy 

    e.g. class Book is unchanged. 

        A textbook "is a" book with an additinal field, so is ComicBook

        class TextBook: public Book { //textbook inherits from book; textbook is a book
            string topic;
        };

        class ComicBook: public Book {
            string protag;
        };

        TextBook and ComicBook inherit title, author and numPages from Book. 

    Book is the base class or the superclass
        TextBook and ComicBook are the derived class or the subclass 

    Note: TEXTBOOK OBJECTS HAVE 4 FIELDS: 3 INHERITED AND 1 NEW FIELD (same for comic).
        We can call on a Text/ComicBook object any public method that we could call on a book object

    TextBook inherited title, author and numPages; these were private in Book
        TextBook objects cannot access them! (can't assign or read)
        If I can't access them how the hell can you initialize them in the constructor?
---------------------------------------
Lecture 17

Inheritance, Virtual Keyword

Recap:
    class Book {
        string title, author;
        int numPages;
        public:
        Book(string title, string author, int numPages) :...
        bool isItHeavy() {return numPages > 300; }
        string getAuthor() { return author; }
        void setAuthor(string auth) { author = auth; }
    }

    class Textbook : public Book {
        string topic;
        public:
        Textbook(string title, string author, int numPages, string topic);
    }


    int main() {
        TextBook tb ...;
        tb.author = ...; // Not allowed
        tb.getAuthor(); // allowed
    }

    TextBook::TextBook( ____, ____, ____, ____)
        : title(title), author(author), numPages(numPages), topic(topic) {} // Doesn't compile.
        // Title, author, numPages are private.
        // When an object is created:
        //  - Space is allocated
        //  - Superclass part of the object is constructed (this looks for default zero-argument constructor of Book)
        //  - Field constructors run / member initialization list
        //  - Constructor body
        // No default (zero-argument) constructor exists for Book

    TextBook::TextBook(string title, string author, int numPages, string topic):
        Book(title, author, numPages), topic(topic) {}
        // You need to use the member initialization list to call the non-default constructor for your superclass.

    Lesson:
        If the superclass does not have a default constructor, call a non-default constructor in the MIL.

    See /inheritance/example1
    "I highly recommend looking through all of these examples." -NN

If the superclass has private members, the subclass cannot access them.
    If you want access to superclass fields, make the superclass fields protected.
    Fields or methods that are protected are accessible to the subclasses (still not accessible to outsiders).
    "If you are an instance of the subclass, then you really have an instance of the superclass as well." -NN

Example of using protected:
    class Book {
        protected:
        string title, author;
        int numPages;
        public:
        ...
    };

    class TextBook : public Book {
        string topic;
        void setAuthor(string auth) { author = auth; }
    }

    int main () {
        TextBook tb('','','','');
        tb.author = "----"; // Won't work. Author would have to be public.
        // TextBook has access to protected author, but only within TextBook's inner code.
    }

Protected breaks encapsulation.
    If we don't want Book's author to ever be Shakespeare, we can't stop TextBook from subverting this limitation on the protected field.
    No way to protect class invariants.
    Advice:
        Private fields, protected get/set methods.
        This doesn't break class invariance, because you have written these get/set methods.

Inheritance creates a "IS A" relationship.
    Recall:
        "OWNS A" embeds object
        "HAS A" pointer to an object, aggregation

    TextBook inherits from a Book. TextBook IS A Book, a Comic IS A Book.

         [Book ]
          __|__
         |     |
  [Textbook] [ Comic  ]
  [ (topic)] [(protag)]

Motivation for virtual keyword:
    Book is considered heavy if it's > 300 pages.
    TextBook is considered heavy if it's > 500 pages.
    Comic is considered heavy if it's > 30 pages.

    class Book {
        // usual fields
        public:
        bool isItHeavy() { return numPages > 300; }
        getNumPages() { return numPages; }
    };

    "Override the isItHeavy method. This requires a public accessor method in the superclass."

    class TextBook : public Book {
        public:
        bool isItHeavy() {
            return getNumPages > 500;
        }
    };
    
    class Comic : public Book {
        public:
        bool isItHeavy() { return getNumPages() > 30; }
    };

    Book b("book", "myauthor", 50);
    b.isItHeavy(); // false
    Comic cb("mycomic", mycomicauthor", 40, "batman");
    cb.isItHeavy(); // true

    "Objects have a 'Vtable' full of pointers to their methods in memory.
     So where we have an instance of Comic, Book's isItHeavy function exists
     in memory but cb's Vtable doesn't point to it."

     What happens if we do this?:
        Book b2 = Comic("mycomic", "mycomicauthor", 40, "batman");
        b2.isItHeavy(); // What do?

        Two options:
            1. Book::isItHeavy runs --> false // This is what happens. The compiler's not smart enough.
            2. Comic::isItHeavy runs --> true

   Book              Comic  
[  title  ]       [  title   ]
[ author  ]       [  author  ]
[numPages ]       [ numPages ]
                  [ protag   ]

When you assign a subclass object to a superclass object, the object is sliced (fields are chopped off). This creates a possible memory leak!
    Comic has been coerced into a Book
    Superclass methods will be called.

    Q: Why would we want to do this?
    A: If we want to declare an array of Books, we can still store Comic books in it.

    "It comes down to casting."

    Q: Can we cast Comics into TextBooks?
    A: _         _
        \_(O_O)_/     "..." -NN

    Comic cb(dontcare, dontcare, 40, dontcare);
    Book *pB = &cb;
    Comic *pcB = &cb;
    pCB->isItHeavy(); // true
    pb->isItHeavy(); // false // Book's isItHeavy runs.
    When you are talking about pointers, no coersion occurs.
    Superclass pointer to a subclass object does NOT slice the object.

Lesson: If we acces an object through a superclass pointer, the superclass method runs (even though there is no slicing).
    The compiler uses the type of the pointer (or reference) to decide which method to call.
        - Does NOT consider the actual type of the object.
        - That's a problem.
        - An array of Books would run the Book::isItHeavy method on everything in the array! :(

    We would like to refer to different Books using Book pointers (or references), and still call the customized subclass method.
    We want the most customized method to run. 

    "EVERYTHING that is true for pointers is true for references."

Using virtual:
    class Book {
        public:
        virtual bool isItHeavy() {...}
    };
    class TextBook/Comic NO CHANGE
    Only the superclass method needs to be declared virtual.

    Comic cb(dontcare, dontcare, 40, dontcare);
    Book *pB = &cb;
    Comic *pcB = &cb;
    pCB->isItHeavy(); // true (obviously, Comic book's method runs)
    pb->isItHeavy(); // true "Virtual? Yup. I'll look at the type of the object." - Compiler

Virtual Method:
    Chooses which method to run based on the type of the actual type of the object.
    The runtime type of the object is used.
        The decsion of what method is called is made when the program is executing, not by the compiler. You pay a small performance penalty.
        Note that this only works with a pointer to the object.
    "It goes all the way down. Even if you have a SpecialComics class."
    The process of finding the method using the runtime type of an object is called dynamic dispatch.
        Every Java method is virtual by default, so you get dynamic dispatch by default.
        There are ways to do this in the compiler, but that's for CS 744.

    /example4
        Books *collection[20];
        ...
        ... // Book, Comic, or TextBooks
        ...
        for (int i = 0; i < 20; i++) {
            collection[i]->isItHeavy()  // ith element of the array, a Book pointer
        }

        This array accomodates multiple types under one abstraction.
         - POLYMORPHISM
            The ability to accomodate multiple types in one abstraction. Explain the virtual keyword. Get job.

    Destructors
        See /example5
            X *xp = new Y(5, 10);
            delete xp;
            // Memory has leaked
            Make X's destructor virtual.
----------------------------------------------
Lecture 18

Make, 2D Arrays, abstract

"We have an array of topics to cover today." -NN :P

Make was covered in the last tutorial. See the examples if you didn't attend/understand.
    make is a linux utility that takes the burdon of keeping track of changed files.
    makefiles have targets, dependencies, and recipes.
        target: main.o
        dependencies: main.cc book.h textbook.h comic.h
        recipe: g++ -c main.cc

        Corresponding makefile line:

            main.o: main.cc book.h textbook.h comic.h
            [TAB]recipe: g++ -c main.cc

            What do we need to create main() ?

                     [main]
                       |
     ,-------------:-----------:------------,
    /              |           |             \
[main.o]       [book.o]   [textbook.o]   [comic.o]
                /  \
        [book.cc] [book.o]

    Note: make looks at the file's modification timestamp, as seen when running "ls -l".
    The hard part here is coming up with all of the dependencies.
        We can do this automatically with g++ -MMD
        .PHONY specifies that a given ":something" is not a target file, but a command to be run "make something".
        .PHONY: clean
        clean:
            ---
        Look at the last example Makefile that's been posted. We have made it as general as possible.
        Just copy and paste this example Makefile and change the OBJECTS line near the top for your Marmoset Makefiles. :)
            Make sure you understand what this file does, though.

2D Array
    "We (the profs) decided to cover this topic in class because there has been some confusion, and it's necessary for A4's 'Flood It' question." -NN

    Stack allocated 2D array:
        int a[10][5]; // 10 rows, 5 columns
        a[i][j] // ith row, jth column
        // *(*(a + i) + j)
        // Useful function header: "foo(int a[][], int i, int j);"
        ________________
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        [  |  |  |  |  ]
        ````````````````

    Heap allocated 2D array:
        int *a[10]; // An array of int pointers.
        a[0] = new int[5];
        a[1] = new int[5];
        // loop through a[i] to initialize these if you want
        // make sure to loop through and delete it all after you're done
        // Rule: Postfix before Prefix /* Read right to left -JR */
        // Aside: int (*a)[10]; // pointer to an array
        // Note: hardcoded numbers like "10" above should be avoided, set it to a variable.

        int *a[10]      new int [5]
         ______      ______________
        [    --]--->[  |  |  |  |  ]  
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        [    --]--->[  |  |  |  |  ]
        ````````    ````````````````

        OR:
            int **a;
            a = new int *[10];
            for (int i = 0; i < 10; i++) { // nested loop to initialize
                a[i] = new int[5];
                for (int j = 0; j < 5; j++) {
                    cin>>a[i][j]; // initialize to stdin (can be whatever)
                }
            }
            for (int i = 0; i < 10; i++) {
                delete [] a[i]; // deletes second dimension of array
            }
            delete [] a; // deletes first dimension of array

Back to our discussion of inheritance:
    Recall that we were previously only concerned with Student's grades.
    What if we are Needles Hall and want to compute a Student's fees instead? But there are both regular and co-op Students...

    class Student {
        ...
        protected:
        int numCourses;
        public:
        virtual int fees(); // allows us to specify the computation based on the type of Student
    }

    class Regular : public Student {
        ...
        public:
        int fees() {return 700 * numCourses; }
        ...
    };

    class Coop : public Student {
        ...
        public:
        int fees() {return 1300*numCourses; }
    };


    Note that the fees method has no implementation in the Student superclass. This incomplete implementation won't compile.
    What should Student::fees do?
    Students are either Regular or Coop, there is no other option.
    Therefore, we DON'T want an implementation.
    Note: we DO need to specify a virtual method in the superclass in order for polymorphism to work.
        e.g.
            Student *students[400];
            for(...) {
                students[i]->fees(); // Students superclass needs a virtual fees method.
            }

    We get this to compile by having a 'pure virtual' method (a method with no implementation).
        Note: This is a vague definition of pure virtual, but it's all we need to know for now.
    class Student {
        ...
        protected:
        int numCourses;
        public:
        virtual int fees() = 0; // Pure virtual method
    };

    BUT this means that any class which has at least one pure virtual method CANNOT BE INSTANTIATED. It is abstract.
        Student s; // Won't work now.
        Note: The Student.cc file therefore shouldn't exist. But there's an exception to this that we'll get to later. /* Sigh... -JR */

    Any instance of a child class of Student will use dynamic dispatch to determine the most customized implementation of fees.
        Note: Dynamic dispatch is a common buzzword in interviews. /* Google this later. -JR */

    Any class that inherits from an abstract class is also abstract, unless all inherited pure virtual methods are implemented.

    A class with no pure virtual method is called a 'concrete class'.
        Every class we've seen so far in the course is a concrete class.

    Uses of abstract classes:
        - Enable polymorphism
        - Share common fields

UML Recap:
    "I'm told that the UML references we've provided are long and tedious." -NN
    
    virtual / pure virtual methods are written in <i>italics</i>.
      If our typography isn't obvious, do "*in italics" or something at the bottom of the page, etc. This is just to help the marker.
    abstract classes - name in italics
    static - underline
        -private +public #protected

    Q: How do you write arrays in UML?
    A: Just add square brackets (assuming it's variable sized), like :integer []
       "I need to double check the array notation, I'll let you know if this answer changes." -NN

Up next: 4 design patterns, two of which are 99.99% necessary for your final project.

Observer Pattern
    We have a "Publish - Subscribe" model.
    One class is the publisher/Subject and generates data.
    Another class is the subscriber/Observer and ingests/consumes/uses the generated information.

    e.g.
        Cells in a spreadsheet: Subject (publisher)
        Graph/plot of cells: Observer (automatically updates based on changes in observed cells)

    "Whenever the subject changes, it notifies any observers of changes." -NN

    See /observer/ObserverUML.pdf
        <i>AbstractSubject</i>
            +attach(Observer *)   "Keep a list of observer to notify."
            +detach(Observer *)
            +notifyObservers()

        <i>AbstractObserver</i>
            <i>+notify()</i>

        ConcreteSubject
            +getState()  "Specifies the change that just happened. What just happened?"

        ConcreteObserver  "Like a spreadsheet cell."
            +notify()     "Something happened, but I won't tell you what exactly."
                          "When the observer is notified, it gets the state of the observer with getState."

        Note: Observer HAS A Subject

    "I will show you a *concrete* example." -NN :P

    Example: Horse Racing
        publisher/Subject: announces winners
        subscribers/Observers: betters

        class Subject {
            Observer *observers[MAX]; // Where MAX is some constant, this is good style.
            int numObservers;
            public:
            bool attach(Observer *o) {...} // better joins (increment numObservers, add to observers)
            bool detach(Observer *o) {...} // better stops betting (decrement numObservers, remove from observers)
            void notifyObservers() {
                for (int i = 0; i < numObservers; i++) {
                    observers[i]->notify; // notify all observers
                }
            }
            virtual ~Subject() {} // We provide a virtual destructor with no implementation, because there is no dynamic memory.
                                  // This will do for now, but we will use this to learn something about pure virtual...
        }

        class Subject {
            ...
            virtual ~Subject() = 0; // pure virtual destructor
                                    // This doesn't work, because subclasses will try to call the parent destructor.
        }

        If in doubt, make the destructor pure virtual BUT STILL IMPLEMENT THE DESTRUCTOR.
        This seems contradictory, but what I said before about not needing an implementation is only vaguely true.
        A subclass will want to call the parent's destructor.
        Subject::~Subject(){} // This line should exist in implementation (Subject.cc)

        So there is something else to pure virtual methods:
            A pure virtual method is a method that subclasses must implement to be considered concrete.
            This is even more complicated because children will attempt to call a parent's destructor, but can't redefine the parent's destructor (same name of "~Subject")
            So a subclass continues to be abstract if it doesn't implement an inherited pure virtual method EXCEPT if it's the destructor.

        "This pure virtual gotcha is the hardest part of the observer pattern. I will revisit this example next lecture." -NN
--------------------------------------------------------
Lecture 19

Observer Pattern / Decorator Pattern / Factory / Template

Recall horse races example:
    class Subject { // virtual subject class
        Observer *observer[max];
        public:
        Subject() ...
        bool attach(Observer *o) {...}
        bool detach(Observer *o) {...}
        void verifyObservers() {...}
        virtual ~Subject() = 0;
    }

    class Observer { // virtual observer pattern
        public:
        virtual void notify = 0;
        virtual ~Observer();
    }

    class HorseRace : public Subject {
        // attach, detach, notify, etc are inherited and we have that functionality
        ifstream in;
        string lastWinner;
        public:
        HorseRace(string fileSource) ...
        ~HorseRace() {...}
        bool runRace() {...}
        string getState() { return lastWinner; }
    }

    class Better : public Observer {
        HorseRace *hRace; // concrete Observer HAS A concrete Subject
        string name, horse;
        public:
        Better(HorseRace *hRace, string name, string horse)
            : hRace(hRace), name(name), horse(horse) {
                hRace->attach(this); // Better becomes an observer of future horse races
            }
        void notify() {
            string winner = hRace->getState(); // returns last winner of horse race
            if (winner == horse) {
                cout << "Yayy!!";
            } else {
                cout << "Oh no not again";
            }
        }
    }

    "For our assignment, we might get away with just using one class. A Cell is both a Subject and an Observer. The number of classes needed is situational."

Decorator Pattern
    e.g.
        A browser window being decorated with scrollbars, etc.
        The window is already running, and it is 'decorated' (new functionality added) during runtime.
        This pattern is common in windowing systems:
            - base window
            - menu
            - scroll bars

    Abstract Component class (window)
        virtual +Operation()
    ConcreteComponent // plain window
        +Operation
    Decorator // IS A Component and HAS A Component
        HAS A Component
        virtual +Operation()
    ConcreteDecA : public Decorator // scroll window
        +operation()
    ConcreteDecB : public Decorator // menu
        +operation()

    Class Component
        Abstract, provides the interface all concrete classes must implement.
    Concrete Decorators
        Inherit from decorator which HAS A component, and IS A component.

    A windown with a scroll bar and menu IS A abstract window, and HAS A window with a scrollbar.
    A window with a scroll bar IS A abstract window and HAS A plain window.

    class Coffee {
        public:
        virtual double cost() = 0;
        virtual  {}
    };

    class Espresso : public Coffee {
        public:
        double cost() { return 1.00; }
        string desc() { return "full roast espresso"; }
    };

    class Topping : public Coffee {
        // HAS A should be a pointer, OWNS A is an embedded object.
        // My coffee HAS cream and sugar, but you can't really separate the two...
        // References will make us happy here.
        protected:
        Coffee &c;
        Topping(coffee &c) : c(c) {}
        ~Topping() { delete &c; }
    };

    class Water : public Topping {
        public:
        Water(coffee &c) : Topping(c) {}
        double cost() { return c.cost() + 0.50; }
        string desc { return c.desc() + " with water"; }
    };

    class Milk : public Topping {
        protected:
        Milk(Coffee &c) : Topping(c) {}
        public:
        double cost() { return c.cost() + 0.25; }
    }

    int main() {
        Coffe *cp;

        cp = new Espresso;
        cp = new Milk(&c);
    }

    see lectures/se/decorator

Factory Method Pattern
    "Suppose we have two enemies - turtles, and bullets."
    Enemy (abstract)
        Turtle
        Bullet
    Level (abstract)
        Normal
        Castle

    We want more bullets in the castle lever, because it's more difficult.

    int main() {
        ...
        Enemy *e = new Turtle;
                 //new Bullet;
    }

    Because the decision of which enemy to create depends on the level,
    place the enemy creation logic inside levels.
    The Level class has a virtual createEnemy method.

    class Level {
        ...
        public:
        virtual Enemy *createEnemy() = 0;
    }

    class Normal : public Level {
        ...
        public:
        Enemy *createEnemy() { // more turtles }
    };

    class Castle : public Level {
        ...
        public:
        Enemy *createEnemy() { // more bullets }
    };

    int main() {
        Level *l = new Castle; // or new Normal;
        while (!Dead) {
            Enemy *e = l->createEnemy();
            // deal with it
        }
    }

    client code never calls enemy constructors.
        Uses the createEnemy Factory method.
        Note: We have seen similar behaviour in the singleton pattern.
            Singleton pattern used the getInstance function.
        Factories integrate well with Singletons.
            If we have a Boss class, we only want one of them.
                Enemy (abstract)
                    Turtle
                    Bullet
                    Boss (Singleton)

                If the Boss only appears at the Castle level,
                only Castle::createEnemy needs to be changed!

                Call Boss::getInstance to return the same Boss.

                Client code is oblivious to the fact that the same enemy object is being returned.

// next time: player.strike(enemy)

Template Method Pattern

    AbstractClass
        +/-differingMethods (virtual)
        +/-commonMethods
    ConcreteClassA
        +/-differingMethods
    ConcreteClassB
        +/-differingMethods
    ConcreteClassC
        +/-differingMethods

    class Turtle : public Enemy {
        public:
        void Draw() {
            drawHead();
            drawShell();
            drawTail();
        }
        private: // NOT virtual, do not want subclasses to override common behaviour
        void drawHead() {...}
        void drawTail() {...}

        protected:
        virtual void drawShell() = 0;
    }
---------------------------------
Lecture 20

Recall: Template Pattern (Applied to our turtle example)
    class Turtle : public Enemy {
      public:
        void draw() {
            drawHead();
            drawShell();
            drawTail();
        }
      private:
        void drawHead() {...}
        void drawTail() {...}
        virtual void drawShell() = 0;
    };

    class RedTurtle : public Turtle {
        void drawShell() { // draw red shell }
    }

Templates
    A motivating example:
        class Node { // linked list capable of storing ints
            int data;
            Node *next;
        };

        We cannot use this to store other types of data.

    Use a template (a class parametrized on some number of types):
        Take the int out of the Node class and replace it with a type parameter,
        which is provided when we create variables of the templated class.

        template <typename T> class Node {
            T data;
            Node<T> *next;
          public:
            Node(T data, Node<T> *next) : data(data) next(next) {}
            T getData() const { return data; }
            Node<T> *getNext() const { return next; }
        };

        Node<int> *intList = new Node<int>(2, new Node<int>(3, NULL));
        Node<char> *charList = new Node<char>('a', new Node<char>('b', NULL));

        Note: If we try to use the wrong type, the compiler will complain.
            (Unless an implicit convertion exists, such as char-to-int ASCII value conversions.)

        Write the template once, then reuse it for different data types.
        The compiler replaces T with whatever type is given before continuing compilation.
        This is relatively memory efficient during execution, but increases compile time.

    Creating a linked list that contains linked lists:
        Node<Node<int> > **linklist; // C++03 requires a space '> >' to prevent operator confusion.

    STL: Standard Template Library
        Dynamic Length Arrays
            Grows (and shrinks) the length automatically.
            'vector' template class, parametrized on one type.
        
            #include <vector>
            using namespace std;
            Vector<int> myVec;
            myVec.push_back(5); // put at end of vector
            myVec.push_back(10);
            for (int i = 0; i < myVec.size(); i++) {
                cout << myVec[i] << endl; // operator[] has been overloaded here
            }

            Note: myVec[i] is not 'range checked'.
            It will not complain if you try to access myVec[9001].
                To range check 0 <= i <= myVec.size(), call myVec.at(i);
            There is also myVec.pop_back(); / removes the last element

        Iterators
            Suppose v is an array.
            Recall pointer arithmetic:
                for (int *p = v; p < v + size; p++) {
                    cout << *p << endl; 
                }

            for (vector<int>::iterator i = v.begin(); i != v.end(); i++) {
                cout << *i << endl;
            }

            An iterator is just an abstraction of a pointer.
            'v.begin()' returns a pointer to the start of the array (vector).
            'v.end()' returns a pointer to ONE PAST the last element in the array (vector), where we should stop the loop.

            for (vector<int>::iterator i = v.rbegin(); i != v.rend(); i++) {
                cout << *i << endl;
            }
            'v.rbegin()' returns a pointer to the last element.
            'v.rend()' returns a pointer to ONE PAST the first element.

            Iterators are VERY USEFUL, because other template classes are not simply arrays.
            More complicated structures such as Binary Search Trees can also be iterated through!

            "iostreams should also have iterators, but I'm not sure what their use case is." -NN

            Array: lookup table of integer keys
                int ---> int
                int ---> string
                int ---> Cell

        'map' (in STL):
            Lookup table, dictionary, association list
                string ---> int
            'map' is a template parametrized on TWO types.

            #include <map>
            using namespace std; // or else use std::map below
            map<string, int> m;

            m["abc"] = 10;
            m["xyz"] = 55;
            
            cout << m["abc"] << endl; // 10
            cout << m["default_value_for_undefined_key"] << endl; // 0
            
            m.erase("abc"); // removes entry from table

            if (m.count("def")) { // can only return 0 or 1 in map, a 1-to-1 mapping
                cout << "boo" << endl;
            }

            Note: multi-maps exist, where count can be > 1.

            We can also iterate over a map!
                Order of iteration is SORTED KEY ORDER (using standard string comparison).
                    ("abc" < "tdb" < "xyz" regardless of initialization order)

Visitor Design Pattern
    Recall: Dynamic dispatch (as opposed to single or double dispatch, which we'll see).
        Virtual method: method that runs depends on the run time type of the object (dynamic dispatch).

    Double Dispatch
        We want to choose a method based on the run time type of 2 objects.

        Enemy (virtual)
            \ Turtle
            \ Bullet
        Weapon (virtual)
            \ Stick
            \ Rock

        There are four different combinations for enemy.strike(weapon).
        Where do we implement the strike method?
        Option 1: Implement 'virtual Enemy::strike(Weapon *w)'
            Here, the strike method depends on the type of the Enemy only, via dynamic dispatch.
            The compiler decides the right hand side (type of Weapon).
        Option 2: Implement 'virtual Weapon::strike(Enemy *e)'
            Here, the strike method depends on the type of the Weapon only, via dynamic dispatch.
            The compiler decides the right hand side (type of Enemy).

        Trick: Use a combination of overriding and overloading.

            class Enemy {
                public:
                virtual void strike(Weapon &w) = 0;
            };

            class Turtle : public Enemy {
                public:
                void strike(Weapon &w) {
                    w.useOn(*this); // type of '*this' is a Turtle, known at compile time.
                }
            };

            class Bullet : public Enemy {
                public:
                void strike(Weapon &w) {
                    w.useOn(*this); // type of '*this' is a Bullet, known at compile time.
                }
            };

            Note: Now we must have a useOn method in our Weapon class that is overloaded.

            class Weapon { // abstract base class
                public:
                virtual void useOn(Turtle &t) = 0;
                virtual void useOn(Bullet &b) = 0; // overloading!
            };

            class Stick : public Weapon {
                void useOn(Turtle &t) { // Stick on Turtle }
                void useOn(Bullet &t) { // Stick on Bullet }
            }

            class Rock : public Weapon {
                public:
                void useOn(Turtle &t) { // Rock on Turtle }
                void useOn(Bullet &b) { // Rock on Bullet }
            }

            int main() {
                Enemy *e = new Bullet; // typically generated by a Factory
                Weapon *w = new Stick;
                e->strike(&w); // at runtime, Bullet's strike method is called
            }

            At run time, Bullet's strike method is called, sending type of '*this' as a Bullet,
            then Stick's useOn gets called with an argument of Bullet.
            So Stick::useOn(Bullet &b) is called. // Stick on Bullet

            Note: this is just one use of the visitor design pattern.
-------------------------------------------------
Lecture 21

Visitor Pattern, Compilation Dependencies

Recall: Dynamic Dispatch
    Depends on 2 objects.
    Add functionality to an existing hierarchy without changing the code in that hierarchy.
        + No cluttering of code.
        + Even if no source code for the hierarchy.

    class Book {
        string title, author;
        int numPages;
        public:
        virtual void accept(BookVisitor &v) {
            v.visit(*this);
        }
    }
    
    class TextBook : public Book {
        ...
        public:
        void accept(BookVisitor &v) {
            v.visit(*this);
        }
    }

    class Comic : public Book {
        ...
        public:
        void accept(BookVisitor &v) {
            v.visit(*this);
        }
    }

    Note: These different implementations of accept() are necessary, because *this is a different object within each class.
        The accept method is overloaded for these multiple types of books.

    class BookVisitor {
        virtual void visit(Book &b) = 0;
        virtual void visit(TextBook &t) = 0;
        virtual void visit(Comic &c) = 0;
    }

    Track how many of each type of book I have.
        Book: Count based on author.
        TextBook: Count based on topic.
        Comic: Count based on protagonist.

        Use a map where the key is a string and the value is the count.
            map<string,int>

        class Catalogue : public BookVisitor {
            map<string,int> myCatalogue;
            public:
            map<string,int> getCatalogue() {
                return myCatalogue;
            }
            void visit(Book &b) {
                myCatalogue[b.getAuthor()]++;
            }
        }

        Note: Asking for a key not in the catalogue returns the default of value's data type.
            In this case, int defaults to 0.

        void visit(TextBook &t) {
            theCatalogue[t.getTopic()]++;
        }

        void visit(Comic &c) {
            theCatalogue[c.getProtagonist()]++;
        }

        See /se/visitors/ for a full implementation of Book and BookVisitor.
            broken/
                book.h: #include "BookVisitor.h"
                BookVisitor.h: #include "book.h"

                A cyclic dependency has been created, even with include guards.
                Solution: We need forward declarations.
                Why? BookVisitor refers to a Book, TextBook, Comic, and the compiler looks for those defeinitions elsewhere.
                    Forward declarations tell the compiler that there will eventually be a definition, so is won't need to paste in included code.

    What creates a cyclic dependency?
        In BookVisitor we included book.h only because Book is a parameter in a method.
        This is overkill.
        All the compiler needs to know is what is book (same for Comic & TextBook).

        Remove the #include.
        Place a forward declaration "class Book;"
        Advantage: reduce compile time (prevents the hard work of the compiler pasting necessary code).

Compilation Dependencies
    When to forward declare vs when to include (a class).
    a.h:
        class A {...};

    b.h:
        class B : public A {...};

    In b.h, can we just forward-declare A or do we need to #include "a.h"?
    Here we need to #include, because inheritance relies on the implementation.
        We need to know the size of A to allocate in memory!

    c.h:
        class C {
            A myA;
        };

    In c.h, we also need to #include "a.h", because C OWNS A A.
        In order to allocate space for C, we need to know the size of A.

    d.h:
        class D {
            A *myA;
        };

    In d.h, we only need to forward-declare A.
        The size of D is constant, because it only contains a POINTER to A.

    e.h:
        class E {
            A foo(A x);
        };

    In e.h, the compiler only needs to know that a type A exists somewhere.
        The implementation is not needed, so a forward declaration will suffice.

    d.cc:
        void D::bar() {
            myA->someMethod();
        }

    In d.cc, the compiler needs to know that A::someMethod exists.
        We need to #include "a.h".
        Note: the dependency is between d.cc and a.h, but NOT between d.h and a.h

    Note: Compilation dependencies are thus created when an implementations are included in each other.

    We have always been including <iostream>.
        This has IO class definitions.
        We should really just #include <iosfwd>, the iostream forward declarations.
            This will speed up compile time, because only forward declarations are used.
            Of course this only works when there are no compilation dependencies for <iostream>.

    If we look at window.h from assignment 4:
        class XWindow {
            Display *d;
            Window w;
            int s;
            GC gc; // private
            public:
            ...
        };

    Client code (a .cc file) will include window.h and use the public methods in XWindow.
    Because of the include, there is a compilation dependency.
    So if window.h changes, client code must be recompiled,
        even if the change is to private fields in XWindow.

    To prevent this problem, we use the pImpl idiom (pointer to Implementation).
        Place the private fields in a separate implementation class.
        Place a pointer to them in our class.

        struct XWindowImpl { // public by default
            Display *d;
            Window w;
            int s;
            GC gc;
        };

        window.h:
            class XWindowImpl; // same as "struct XWindowImpl;"
            class XWindowImpl *pImpl;
                public:
                ...
            };

        Note: We can't just forward declare a public method of a class.

        window.cc:
            #include "window.h"
            #include "XWindowImpl.h"
            XWindow::XWindow() : pImpl(new XWindowImpl) {}

        Previously private fields are now accessed through pImpl->d, pImple->w.
        This forces us to write getters and setters, which is nice and clean.

    In UML form:
        XWindow
            HAS A XWindowImpl

    More general:
        Window
            HAS A WindowImpl
        MacWindowImpl : public WindowImpl
        WinWindowImpl : public WindowImpl

    The Window class has a pointer to a base class, or superclass.
        class Window {
            WindowImpl *pImpl;
            ...
        };

        pImpl idiom with subclassing to accomodate different/alternate implementation.

        This is the Bridge Pattern.
-------------------------------------
Lecture 22

Big 2/3, Casting, Exceptions

Brief Talk on Measuring Design Quality
    We can't just tell our partner, "This sucks", we have to justify it with formal notions of design.
    
    Coupling
        The degree to which program modules depend on each other.
        Desired: Low Coupling
            Modules communicate using an interface (in our case, public methods); not concerned with implementation details.

        Not Desired: High Coupling
            Modules rely on implementation details (via friendship, public fields, etc.).

    Cohesion
        How closely are components within a module related.
        Desired: High Cohesion
            Components of a module work togther to achieve one task.

        Not desired: Low Cohesion
            Doing multiple disjoint/unrelated tasks in one module/function.
            No separation of concerns.
            e.g. Algorithm header has a collection of unrelated algorithms (this has been fixed in C++11).

Big 2/3
    Recall: When using inheritance, make destructors for the base classes virtual.

    Copy Constructor (Recall: this constructs a new object as a copy of another.)
        class Book {
            ...
            public:
            Book(const Book &other);
            ...
        };

        class TextBook : public Book {
            string topic;
            public:
            // Suppose we have no copy constructor implemented here.
        };

        int main() {
            TextBook t("Algorithms", "CLRS", 500, "CS"); // title, author, numPages, topic
            TextBook c = t; // Requires a copy constructor - so the default copy constructor will run.
            // Calls Book::Book(const Book &other)
            // Then does default field-for-field copy of TextBook fields (string).
        }

        When an object is constructed that inherits from another object, we first create the "superclass part" of the object.
        So the default copy constructor will call Book's copy constructor.

        TextBook's default copy contructor looks like this:
            TextBook::TextBook(const TextBook &other)
                : Book(other), topic(topic) {}

    Let's look at Book's assigment operator (Recall: this does a field-for-field copy of one object into another existing one.)
        Book &Book::operator=(const Book &other) {
            ... // field for field copy
            return *this;
        }

        // in main:
        TextBook b(..., ..., ..., ...);
        b = t;
        // Assuming operator= is not implemented for TextBook, the default one runs.

    If we want to mimic TextBook's default operator=:
        TextBook &TextBook::operator=(const TExtBook &o) {
            Book::operator=(o);
            topic = o.topic;
            return *this;
        }

        Note: This is an easy example, since no dynamic memory is involved.
            These are only shallow copies, we aslo need to look into doing deep copies when necessary.

    If fields contain dynamically allocated memory then you need to deallocate previously-allocated memory.
    Always perform the operation on the superclass first, and then do the operation on the subclass.

    "That wasn't too technical so far. Now we'll get really technical."

    TextBook b1("A", "Nomair", 200, "Physics");
    TextBook b2("B", "Adam", 300, "CS");
    // Two Book pointers to TextBooks:
    Book *pb1 = &b1;
    Book *pb2 = &b2;
    // Assigning b2 to b1, but through Book pointers:
    *pb1 = *pb2; // This will compile. But what happens?

    The compiler will look at the declared type of the left hand side, see a Book *, and call the assignment operator for Book.
    Book's operator= is executed.
    Regardless of whether we use our own Book::Operator= or the default, it's only concerned with Book's fields!
        Assigns Book's fields from b2 to b1.
    pb1 now points to a (Text)Book which has
        title = B
        author = Adam
        numPages = 300
        topic = Physics // !!!

        This is called partial assignment, and should be avoided.
        Solution: Use virtual to prevent partial assignment.

    // But there is a problem with the following code:
        class Book {
            ...
            public:
            virtual Book &operator=(const Book &other);
            ...
        };

        class TextBook : public Book {
            ...
            public:
            TextBook &operator=(const TextBook &other);
            ...
        }
    // The signature of operator= has changed (TextBook argument instead of Book)!
    // TextBook's operator= is NOT overriding Book's operator=, it's overloading.
    // We need TextBook's operator= to override the virtual signature.

    // Fixed TextBook class:
        class TextBook : public Book {
            ...
            public:
            TextBook &operator=(const Book &other); // This is now a valid override.
            ...
        };

        But what are the repurcussions of working so hard to implement a copy constructor?

        TextBook c(..., ..., ..., ...);
        c = Book(..., ..., ...); // !!!

        Here, the compiler will see a TextBook in c, and will call TextBook::operator=
            But because this copy contructor takes any Book, what is c's topic?

        // Or if we do:
        Comic cb(..., ..., ..., ...)
        c = cb; // !!!

        This is called mixed assignment, and should also be avoided.


    Non-virtual assignment operator leads to partial assignment (compiler decides which one to call).
    But if we override operator= to take any Book, we have mixed assignment.
    How do we avoid both of these?
        Recommendation: Make the superclass abstract!

        UML:
            <i>AbstractBook</i> // contains fields that were in Book
                NormalBook
                TextBook
                Comic

        // Note: the following isn't virtual...
            class AbstractBook {
                string title, author;
                int numPages;protected:
                AbstractBook &operator=(const AbstractBook &ab);
                public:
                AbstractBook(...) : ...; // constructor
                virtual ~AbstractBook();
            }
        // We need a pure virtual method. Use the pure virtual destructor method!
            ...
            virtual ~abstractBook() = 0;
            ..
        // Recall: We must still implement the pure virtual destructor in, say, abstractbook.cc.

        Comics and TextBooks are the same as before, except that they inherit from AbstractBook instead of Book.
        Note: In the svn repository, NormalBook is called Book and inherits from AbstractBook, don't let this confuse you.

        class NormalBook : public AbstractBook {
            public:
            ...
            NormalBook &operator=(const NormalBook &o) {
                AbstractBook::operator=(o); // we can do this because it's protected in the superclass.
                return *this;
            }
        }

        Now, operator= is no longer just virtual, so we have prevented mixed assignments.
        Partial assignment occuring when we assign with superclass pointers,
            and the compiler calls the superclass operator=, is now prevented.
            (We still need to remember to implement operator= in the subclasses.)
        We have dissallowed partial assignment by making operator= protected.
            Outsiders can no longer call this method.

        TextBook b1(...);
        TextBook b2(...);
        AbstractBook *pb1 = &b1;
        AbstractBook *pb2 = &b2;
        *pb1 = *pb2; // compiler error

        This is great, because we prefer a compiler error over a hidden partial assignment.

Casting

    Node n;
    int *ip = (int*)&n; // treat this as an address of an integer
    C-style casting is very powerful, and will let you cast anything into anything.
    C++ has broken down the same style of casting, but divided it into 4 types of casts.
    "You can still shoot yourself in the foot, but you must now think about it." -NN

    4 types of C++ casts: "Four ways to shoot yourself in the foot in C++." -NN
        1. static_cast
            These are "sensible casts" that make sense.

            int m = 9;
            int n = 2;
            cout << m/n << endl; // prints 4. What if we wanted 4.5?
            cout << static_cast<double>(m)/n << endl; // prints 4.5

            Book *b = new TextBook(...);
            When you KNOW that b is a pointer to a TextBook, you can use static_cast.
            TextBook *t = static_cast<TextBook *>(b);
            This is an unchecked cast, so you need to know what you are doing.
                You are telling the compiler 'trust me, I know what I'm doing, this is a TextBook'.
                If you mess this up and the cast fails, t->getTopic() would return rubbish or some unpredictable, undefined behaviour.

        2. reinterpret_cast
            "We won't talk about this much, because we shouldn't really need this in our CS career at UW." -NN
            Cast a given value to ANY type.

            Vec v;
            Student *s = reinterpret_cast<Student *>(&v);

            These casts are completely compiler-dependent.
            We could overcome someone's declaration of a private field.
            We could reinterpret a 1D array as a 2D array, and vice-versa.
            These are "weird casts" that do really cool, nerdy, low-level things.
            This is very low-level, and relies on knowing the layout of bits in memory.

        3. const_cast
            Gives or removes const-ness of a value.

            void g(int *p) {...} // non-const pointer
            void f(const int *q) {
                g(q); // compiler error, since non-consts can be sent to consts but not vice-versa
                g(const_cast<int *>(q)); // compiles!
            }

            If q is changed by g, we get undefined behaviour. You have shot yourself in the foot.
            We might want to do this if we have a library function we can't modify, and we're being lazy.

        4. dynamic_cast "The last, most useful type of cast. I truly recommend using this." -NN
            Allows for type-safe casting (failsafes are in place to prevent you from shooting yourself in the foot).
            Most useful when using polymorphism.

            vector<Book *> myBooks;
            ... // put stuff in myBooks
            Book *b1 = myBooks[5];

            If we are hoping myBooks[5] is a TextBook, we currently rely on properly defined virtual methods.
            We can't do a static_cast here, because we don't know for sure what myBooks[5] is at compile-time.
            We want to tentatively cast and see what happens.

            TextBook *t = dynamic_cast<TextBook *>(b1);

            At runtime, this checks to see if b1 is of type TextBook.
                If the cast succeeds, t is a valid pointer to a TextBook.
                If it fails, t is NULL.
            So we can do the following:

            if (t) t->getTopic();
            else cout << "Not a textbook." << endl;

            Note: This also works with references, but we'll get to that later.

        Note: These are templated functions, and the cast<type>(var) syntax is consistent.
--------------------------------------
Lecture 23

Casting/Exceptions/Course Evaluations

"Exceptions are definitely on the exam. I just wrote the question!" -NN

Back to our casting discussion:
    Dynamic Casting Continued
        dynamic_cast<T *>(expr)
        
        vector<Book *> myBooks;
        Book *b = myBooks[i];

        Dynamic cast tentatively performs the cast.
        If the cast fails, the pointer is set to NULL (the dynamic cast evaluates to NULL).
        If it is successful, you get a pointer as desired.

        Comic *c = dynamic_cast<Comic *>(b);
        if (C) cout << c->getProtag();
        else cout << "Not a comic!";

        Dynamic cast will let you check the runtime type of an object and let you make decisions.
        You can only use dynamic_cast if your class hierarchy has at least one virtual method.
            Classes with at least one virtual method result in its instances having an "extra" pointer
            to a virtual table (vtable).

            "Vtables are on the cutting board for the final, maybe we'll talk about it in detail on Thursday." -NN

Runtime Type Information (RTTI)
    Using dynamic_casts to find the runtime type of an object or pointer.
        e.g.
            string whatIsIt(Book *b) { // b is not NULL
                if (dynamic_cast<Comic *>(b)) {
                    cout << "It's a Comic!";
                } else if (dynamic_cast<TexttBook *>(b)){
                    cout << "It's a TextBook!";
                } else {
                    cout << "It's a Book!";
                }
            }

        What can we say about whatIsIt's design quality?
            It's terrible.
            It has high coupling ("Or is that cohesion? No, it's high coupling. That would've lost me a mark on the exam. Hint Hint." -NN).
            Highly coupled: poor design
            Brittle: changes to the class hierarchy requires you to search all uses of code relying on RTTI.
                If we add a CookBook, the whatIsIt function will incorrectly say it's a Book.
                We should still use dynamic casting, but only in moderation.
                If we find ourselves using a similar sequence of 'if - else if' statements ALL OVER our code, something is wrong.

            Better design:
                Use virtual methods.
                A virtual whatIsIt method in a new CookBook class would simply define whatIsIt to say "It's a CookBook!".
                This is the visitor design pattern!

Now suppose we have the following code:
    Book &b = ...;
    Comic &c = dynamic_cast<Comic &>(b);
    
    Note: references are a type, and dynamic_cast takes a type in the angle brackets, so we pass Comic & type to dynamic_cast.
    If b is a reference to a Comic object, c becomes a reference to the same object.
    What if b is NOT a reference to a Comic?
        References cannot be NULL!
        We need to handle this.

Error Handling
    In C:
        Function returns status code, or
        Sets global error number value (errno).
        This relies on the programmer to actively check error values.
        You would have to be very meticulous to check for such errors everywhere.

    In C++, what kind of error conditions can occur?
        1. Failed dynamic cast to a reference.
        2. What if new fails (no more memory)?
        3. What if the range check fails in a vector's at method?

        See exceptions/rangeError.cc:
            vector<int> v;
            v.push_back(2);
            v.push_back(4);
            v.push_back(6);
            cout << v.at(3) << endl; // out of range
            
            This compiles but when we run it:
                "terminate called after throwing instance of 'std::out_of_range'"
                An exception is 'thrown' (or 'raised').
        exceptions/rangeErrorCaught.cc:
            ...
            try {
                cout << v.at(3) << endl; // out of range
            }
            catch (out_of_range r) {
                cerr << "Bad range " << r.what() << endl;
            }
            cout << "Done." << endl;

            Output when executed:
                Bad range vector::out_of_range
                Done.
            This lets us catch an error, deal with it, and move on.
            Note that we are basically declaring a variable r that becomes the exception.

    When an error occurs, an exception is raised/thrown.
    The default behaviour of an exception is to terminate the program.
    To prevent program crashes, we must handle/catch the exception.
    Note: raise and handle are often used together in terminology, as well as throw and catch.
        These are synonymous, and are two different ways of saying the same thing.

    See exceptions/callchain.cc
        void f() {
            cout << "Start f << endl;
            throw(out_of_range("f")); // Note: out_of_range("f") is a constructor call.
            cout << "Finish f" << endl;
        }

        void g() {
            cout << "Start g" << endl;
            f();
            cout << "Finish g" << endl;
        }
        
        void h() {
            cout << "Start h" << endl;
            g();
            cout << "Finish h" << endl;
        }

        int main () { 
            try {
                h();
            } catch (out_of_range) {
                cout << "Range error" << endl;
            }
            cout << "Finish main" << endl;
        }

        Output:
            Start main
            Start h
            Start g
            Start f
            Range Error
            Finish main

        Note: When the error is thrown the call stack is 'unwound', and stack frames are popped off the stack until
         we find an error handler or until we pop everything. This is an unhandled error, so the program terminates.

        Note: When the program terminates, this puts us at risk of leaking memory! This is the topic for Thursday's lecture.

        When an exception is throw, the call stack begins to unwind, looking for a suitable catch block.
            If no catch is found, program terminates.
            If catch is found, the handler executes.
                The next line/statement of code run AFTER THE CATCH executes.

    Error Recovery can be a multi-stage process,
        A handler can do part of the recovery and then ask a function lower in the call stack to complete the recovery. 
            e.g.
                try {
                    // exceptional code
                } catch (SomeErrorType e) {
                    // partial recovery
                    throw SomeOtherException(...);
                }

            Note: The above handler catches all exceptions of type SomeErrorType OR any subclasses of SomeErrorType.

            Alternately, we could throw two different things:
                OPTION 1: throw;
                    Throws EXACTLY the same exception object that we just caught
                OPTION 2: throw e;
                    Throws an exception necessarily of type SomeErrorType.
                    Catching a subtype exception object as a supertype object cases slicing.
                    It catches an object as a base object SomeErrorType.
                    Some slicing occurs, and the sliced base object is thrown.
                    This is a very subtle difference from "throw;".

                ADVICE: Use option 1, "throw;".

    All C++ exceptions inherit from a class named "exception".
        Exceptions don't need to inherit from any base class.
        So we need a special syntax to catch ALL exceptions.
        To catch all exceptions, we do this:
            try {
                // some code
            } catch (...) { // THREE LITERAL DOTS, '...', FOR THE FIRST TIME EVER.
                // some more code
            }
        This lets us throw ANYTHING, even base types like integers.
        See exceptions/
                recfact.cc // using recursion to calculate a factorial
                exfact.cc // using exceptions to calulate a factorial
                    void fact(int n) {
                        if (n== 0) throw 1;
                        try: {
                            ...
                        }
                    }

                recfib.cc // similar with fibonacci
                exfib.cc
                
                Lesson: We can even do cool, nerdy calculations with exceptions.
                    BUT exceptions are practically 1000x slower than using functions.
                    Exceptions should be exceptional.
---------------------------------------------
Lecture 24

Exceptions, Exception Safety

Notes:
Course feedback: (27%) :(
A5 Due Date: (Midnight Sunday)
Today's Lecture: Part of final exam (wink wink)
"I can guaruntee that part of this lecture is on the final." -NN

Exceptions
    Good Practice: Create your own exception class or use an existing one.
        e.g.
            class BadInput {};
            try {
                int n;
                if (!(cin >> n)) throw BadInput(); // BadInput constructor
            }
            catch (BadInput &) { ... }

        Note: I snuck a reference into this example.
        You can catch an exception by reference.
            You are suppressing the copy of the object.
            As a stack unwinds, there generally has to be at least one copy
             of the object when frames are deleted as the stack unwinds.
            
            With references:
            + We prevent a second copy from taking place.
            + We do not force object coercion.
            Note: Exception still has to be copied from the stack where it was
              thrown to the frame where it was caught.
            Advice: Catch by reference. To rethrow, just 'throw'.
            Note: If you have a reference to a supertype, you can't catch a
              reference to a subtype.
            If a cast to a reference fails, we get a bad_cast exception.

    If new fails (no more memory), we get a bad_alloc exception.
        "But if we get a bad_alloc, we are probably already doomed.
         You have run out of heap space!" -NN
    If vector.at() fails, we get an out_of_range exception.

    Recall the previous lecture's operator= example:
        Book *p = new Comic(...);
        Book *q = new Comic(...);
        *p = *q
    If Operator= isn't declared virtual, we get partial assignment.
    If Operator= IS virtual, we get the correct assignment.
    So we had something like:
        virtual Comic &operator=(const Book &other) {
            Comic &co = dynamic_cast<Comic &>(other);
            title = co.title;
            author = co.author;
            ...
            protag = co.protag;
            return *this;
        }

        If dynamic_cast fails above, bad_cast exception is thrown.
        Someone somewhere has to catch this exception.
        When we call the assignment operator, we could do:
            try{ *p = *q; } catch(bad_cast &) cout << "oops";
        Note: We can't really do try/catch inside the operator=,
         because we wouldn't be able to recover.
        Note: dynamic_cast takes care of the const part, too.
        
Exception Safety
    Make sure you review this part too. (wink, wink)
    
    void f() {
        MyClass *p = new MyClass;
        MYClass q;
        g();
    }
    
    Does the above leak memory? Yes.
        p has not been freed. 
    
    void f() {
        MyClass *p = new MyClass;
        MyClass q;
        g();
        delete p;
    }

    Does it leak memory now? MAYBE.
    What happens if g throws an exception?
        delete wouldn't be called!
        We have a memory leak.
        Note: q is automatically deleted when out of scope.

    This example is motivation for exception safety.

    Exception Safety: We need to guaruntee that exceptions don't
     'leave scars'.
     (At least no leaks/dangling pointers)

    C++ promises that if an exception is thrown and the stack is
     unwinding, destructors for stack-allocated objects are called
     as the stack is unwinding.
    "You are on your own when it comes to dynamic memory. As usual." -NN
    So q will not leak, but p will leak.

    To make this code exception safe, we do the following:
        void f() {
            MyClass *p = new MyClass;
            MyClass q;
            try {
                g();
            }
            catch (...) {
                delete p;
                throw;
            }
            delete p;
        }

    "This is very ugly and tedious, but I'll teach you a better way." -NN
    Tedious
        Java solves this with the 'finally' clause.
        Scheme has dynamic_wind.
        C++ has neither.
            It doesn't need it!
    The good practice is to allocate objects on the stack.
        What do we do if we need dynamic memory? We'll see soon.

    Never ever ever let a destructor throw an exception!
        "Think back to the C++ promise (above)." -NN
        As we unwind the stack and destructors are called due to an
         exception, if a destructor raises another, we crash and burn.
        This would cause two live exceptions.
        C++ specification says that the program stops immediately at
         the instruction that raised the second exception.
        Note: Code will compile with exceptional destructors, but the
         program will halt if it ever causes two exceptions at once.
        Note: Empty catch blocks "swallow" the exception. This is a
         common laziness in Java, and should be avoided.

    This brings us to a C++ idiom: RAII
        Resource Acquisition Is Initialization

        Every resource should be wrapped in a stack allocated object.
            e.g.
                ifstream f("file.txt"); // Recall: this was a midterm question.
            File is opened (acquired) when f is initialized.
            We were already using RAII, without knowing it.
            When f goes out of scope, the istream destructor runs,
             and releases the resource (the file).
            Exceptions do not change this at all.
            If an exception occurs, then during stack unwinding the
             destructor for ifstream will run.
                No memory leaks!
            So, we should treat heap allocated memory as a resource.
            C++ Standard Template Library privides 'class auto_ptr<T>
                The constructor takes a pointer to some type T.
                The destructor deletes the pointer that it stores.
                Both operator* and operator-> are overloaded.
                    So we can treat an auto_ptr as if it were just a
                     normal pointer.
        See lectures/C++/13-auto_ptr:
            class Basic { ... };
            int main() {
                auto_ptr<Basic> bp(new Basic(5));
                cout << "Access x through smart pointer: " << bp->x << endl;
            }

            We don't have to call delete after using new here! Yay!

        So we can rewrite our f function above as the following:
            f() {
                auto_pt<MyClass> p(new MyClass);
                MyClass q;
                g();
            }

            This is beautiful. But there is a problem.

        Problem:
            class C {};
            auto_ptr<C>(new C);
            auto_ptr<C> q = p; // q and p point to the same object

        We know that p and q are stack allocated, so when p goes out
         of scope it will automatically delete the object.
        If p and q do point to same object, this leads to a double free.
        So in the above code, C++ says that q "steals" what's inside p,
         and sets p to NULL.
        C++3 has auto_ptr.
        C++11 has uniq_ptr (equivalent to C++3's auto_ptr).
         as well as shared_ptr, which keeps track of how many
         pointers point to an object.

    We have 3 levels of Exception Safety:
        1. Basic guaruntee:
            If an exception occurs, the program is in a valid state
             (no memory leaks, no inconsistent or dangling pointers).

        2. Strong guaruntee:
            What can be called "atomic".
            If an exception occurs while running a function f, then
             the state of the program is as if f never ran.
            Note: Strong guaruntee implies basic guaruntee.

        3. No throw guaruntee:
            A function f will never throw an exception, it always
             achieves its purpose.

    A technical example:
        class A { ... };
        class B { ... };
        class C {
            A a;
            B b;
            public:
            void f() {
                a.g();
                b.h();
            }
        };

        What guaruntee can f have?
            If h throws then g has already occured.
            If g had nonlocal side effects, we don't have a strong
             guaruntee.
        
        Assume g and h have no local side effects.
        Now, we can achieve a strong guaruntee for f with the following:
        f() {
            A atemp = a;
            B btemp = b;

            atemp.g();
            btemp.h();

            a = atemp;
            b = btemp;
        }

        Almost a strong guaruntee...
        What if 'b = btemp' throws an exception in the assignment operator?
        
        Use the pImpl idiom:
            "Copy the implementation over and use a pointer."
            struct CImpl { A a; B b; }
            class C {
                auto_ptr<CImpl> pImpl;
                void f() {
                    auto_ptr<CImpl> temp(new CImpl (*pImpl));
                    temp->a.g();
                    temp->b.h();
                    std::swap(pImpl, temp);
            }

            Now we have a strong guaruntee.

"Read the instructions on the exam VERY carefully!" -NN
"That is it." -NN

*applause*
------------------------------------------
Tutorial 1

Kristen Bradley
Marmoset test problems? cs246@uwaterloo.ca
Office Hours:
    WF: 1:30-2:30
    Th: 2-4

Summary
    Shell Review
    I/O Redirection/Piping
    Regular Expressions and grep

Just typing 'cd' returns you to home directory
'ls' - "let's see"
sort wordcollection - sorts wordcollection
sort -r wordCollection | uniq -c
    prints uniqueness count of each word
head - returns first 10 lines of the file
tail - returns last 10 lines of the file
    tail -n 5 for last five words
    tail -n +5 leaves out last five lines

Classic > Redirection
    ./printer > printer.out 2> printer.err
    ./printer > out 2> out   Doesn't work, overwrites first out!
    ./printer 1> out 2>&1    Prints everything, but err is printed first! (Not buffered)
    ./printer >/dev/null

    Order of redirection matters!
    ./printer 2>&1 1>out    Doesn't redirect err to file, since 1 is currently the screen.

    sort wordCollection | uniq -c | sort | tail > topten

Regular Expressions! \o/
    ^ - start of line
    $ - end of line
    . - matches any char
    ? - matches previous item 0 or 1
    * - matches prev item 0 or more
    + - matches prev item 1 or more
    [] - matches one of
    [^] - matches anything except
    expr1|expr2 - matches one of expr1 or expr2

    egrep -n "count" *.c    Finds occurences of 'count' in all files, along with line numbers
    egrep "^a$" /usr/share/ddict/words
    egrep "^a.*z$" /usr/share/ddict/words
    egrep "^a.z$" /usr/share/ddict/words
    egrep "(^a)|(z$)"    Begins with an 'z' or ends with a 'z'
    egrep "^[^aeiouAEIOU]*$"
    egrep "([aeiou].*)([aeiou].*)+"        At least two vowels
    egrep "^ *count *= *((0)|(1) *; *$" *.c         Any amount of whitespace within code

End-of-lecture tips:
    :1000        Jumps to line 1000
    :0            Jumps to top of file
    :$            Jumps to end of file
    /int        Search for 'int', navigate with N or SHIFT-N
    /"a.*z"     Regular expressions!
    egrep -i    Ignores cases
---------------------------------
Tutorial 2

    Quotes
    Shell Scripting
    Testing
    C++ I/O

Double quotes - suppress globbing
    echo "*"

Single quotes - suppresses everything
    echo '*'
    'cat word.txt'

Back quotes - running aother command, grab input from another source
    egrep `cat word.txt` /usr/share/dict/words
    whereas egrep '`cat word.txt`' /usr/share/dict/words  searched for string "`cat word.txt`"
    echo "Hello `whoami`. "'Today is `date`' --> "Hello jrrideou. Today is `date`"

Shell Scripts
    $# number of args
    $0 name of program
    $1, $2, ... nth arg
    $@ all args

    echo "Script name: ${0}"
    echo "First arg: ${3}"
    n=4
    x=n
    echo "Fourth arg: ${!n}"
    echo "Fourth arg: ${!4}"

#!/bin/bash

echo "Hello `whaomi`!"
echo "Today is `date`"

permission will be denied unless chmod, sudo
run $ bash simple.script
or $ chmod u+x simple.script

#!/bin/bash

usage(){
    echo "ERROR" >2
    exit 1             # 0 means success, 1 is not
}

if [ ${#} -eq 1 ]; then
    usage            
elif [ ${1} -lt 1 ]; then
    usage
fi

i=$(( ${1} - 1 ))
total = ${1}
while [ "${i}" -gt 1 ]; do                 # square braces must have spaces before/after []
    total=$(( ${total} * ${i} ))
    i=$(( ${i} - 1 ))
done
echo "${1} factorial is ${total}"         # curly braces required for explicit variable name access ($total. looks for var named "total.")

Testing

Given a program that reads from stdin a list of integers with the goal of determining if the combination of a list of integers can sum to the last integer, (>=0)
n, x1, ..., xn, y
(x, ... , xn) is ascending
Try testing:
    "large" input
    large volume input
    correct solutions (a variety)
    example solution(s)
    edge cases (zeros, etc.)
    target <(sum of all xi)
    target is less than max but still attainable
    y is odd but all x are even

C++ IO

Three types of streams:
    cin (stdin)
    cout (stdout)
    cerr (stderr)

Must #include <iostream>
*There is also an #include <string> library

    cout << "Please choose a number";
    while (cin >> choice) {
        // cin needs to be read at least once before it can hit eof or fail
        if (choice > numChoices)
            cerr << "Invalid Number" << endl;
        else
            cout << phrases[choice-1] << endl;
    ...

***Print End of Line character at end of program to pass Marmoset tests!!!

vim - can see more things than once
    :tabedit (navigate with G,T)
    :vsplit (side by side editing)
        :split horizontal
        change with CTRL-W
    }
-----------------------------
Tutorial 3

Strings, Filestreams, Example

#<include <string>
#include <iostream>

using namespace std;
int main() {
    string str = "Over 9000!!!";
    cout << str[5] << endl;
    cout << str.at(5) << endl;
    cout << str.length() << endl;
    cout << str.size() << endl;
    cout << str.substr(0,6) << endl; // returns [0-5]
    cout << str.at(20) << endl; // Throws an exception
}

Filestreams
    #Include <fstream>
using namespace std; // Don't have to say stdstring

int main () {
    string str1 = "Hello world.";
    string str("infile");     
    ifstream ifs(str.c_str()); // "ifs filename must be C-style string" (null terminated)
    ofstream ofs("outfile");
    string s;
    ifs >> s;
    if (! ifs.fail())
        for (int i=s.size()-1; i >= 0; --i)
            ofs << s.at(i);
        ofs << endl // Tests will fail in marmoset if you don't have end of line chars
}

Read first n lines of a file and write each number in that file which is divisible by a given number x.
./divisor
n
infile
x
outfile

divisorExample.cpp
// Multiple cins can be on different lines since whitespace is ignored
getline(instream, lines[i])
istringstream ss(lines[i])

Test:
    Negative numbers
    Test divide by zero
    Boundary cases
        Max Number of Lines
        Max+1 Lines
        Zero Lines
    Empty Input File
    Don't test error cases, just edge/corner cases "Only give our programs valid input"

How do you create an empty file?
    cat > empty.out
    then CTRL-D
    OR
    touch empty2.out

Vim tips:
    Copy & Paste
    V for visual mode, move curser to select
    Y copy
    P paste
    ctrl-v visual block (excel selection)
    shift-v line selection
    In command mode: w goes to next word
        b back to beginning of line
-------------------------------------------
Tutorial 4

No assignment the same week as the midterm.

Pointers and References
Memory Management
    Should have to use heap-allocated memory for question 6 (not malloc)
Overloading

int x = 42;
int *y = &x; // pointer to x
int &z = x; // reference to x

x == z; // true
x == y; // false? (the compiler crashes here and stops you from comparing int to ptr)
&x == y; // true
z == y; // crash
&x == &z; // true (comparing the address of x to 'itself')

    "Pointers and integers are incomparable, like ..."

const int *a = &x;
*a = 20; // nope
a = &y; // yep (mutating a, not the const int a points to)
a = &z; // yep

int * const b = &x;
*b = 10; // yep
b = &y; // nope
b = &z; // nope, for two reasons: trying to change what b is pointing to, and z is not an int (while b is a pointer to a _const int_)

Passing things by reference and passing things by value:
    int foo(int *p, int q, int &r)
    Arguments are by address, value, and reference, respectively.

    int foo2(const int &r);
        constant reference
        prevents copying and prevents changing

        can call foo2(10);

Memory Management
    Memory stored on the stack
    invalid.cc:
        Declared variables become invalid outside of block/function scopes

        Not using malloc/free, we are using new/delete

        int *p = new int; // creates int in the heap
        ...
        delete p;

        int *q = new int[10];
        ...
        delete[] q;

        valgrind ./a.out
            analyzes memory use

Overloading Functions
    int foo(int x, int y);

    Which of these are valid overloads of above?
        int foo(int x); // yep
        double foo(int x, int y); // nope (return value is ignored)
        int foo(double x, int y); // yep
        int foo(double x, double y); // yep
        int foo(int x, int y, int z = 7); // it could be called with two ints sometimes, so it doesn't work (ambiguous)

Terminal Tip:
    Screen
-------------------------
Tutorial 5

Midterm is next Thursday!
    It's usually a difficult midterm! (But the final is usually easier)
    Bash and C++ both on the midterm.
    Multiple choice and T/F questions - very tricky, really need to know your stuff.
    Coding questions
    Difficult midterm is meant to be difficult so that you step up your game. Sorry :(

tutorials/05
    Preprocessor
    Classes
    Other stuff

Preprocessor
    #include < >
    #include " "
    #define MAX 10
    #ifdef variable
    #endif

    IMPORTANT (for include guards):
        #ifndef
        #endif

    Include Guards:
        Prevents 'cyclical inclusion'. (See 05/cycle1.h cycle2.h)
            e.g.
                cycle1.h:
                    #include "cycle2.h"
                
                cycle2.h:
                    #include "cycle1.h"

        ALL of our .h files should have include guards.
        Instructors have explicitly asked TAs to deduct marks if we forget include guards.
            e.g.
                #ifndef __VAR__NAME__
                #define __VAR__NAME__

                #endif

            fixing the above:
                #ifndef __CYCLE__2__
                #define __CYCLE__2__
                // cycle2.h
                #endif

                #ifndef __CYCLE__1__
                #define __CYCLE__1__
                // cycle1.h
                #endif

Classes (What we are working with for the next 7 weeks!)
    Difference between Structs and Classes:
        Structure:
            Groups data together.
        Class:
            Groups data and routines/methods.

    An object is an instance of a class.

    e.g.
        String s; // Class: String, object: s
        S.length(); // method
        s.substr(n, m); // method
        s.c_str(); // method
        getline(cin, s); // function, not method (not called from an object)

    See 05/rational-class.cpp rational-struct.cpp
        (The Rational class contains a method that is a separate fuction in the struct example.)

    "this" keyword refers to the current object, although this is done implicitly and we don't really need to write this.
        this->field; // inside a method is equivalent to
        field;

    Operator Overloading
        We have seen:
            int x=1, y=2, z;
            z = x + y;

            String a="Hello", b="World", c;
            c = a + b;

        '+' is being used in multiple situations! This is called operator overloading.

        int operator+(const int &x, const int &y); // this is defined by default in C++

        We can also (re)define '+' for ourselves!
            See 05/operatorOverload.cc
                (Overloads +/-/<< operators for our 'Rational' objects.)

                ostream& operator<<(ostream &out, const Rational &r) {
                    out << r.numer << "/" << r.denom;
                    return out; // MUST return out when overloading stream operators!
                }

    We'll do a bunch of this with the iString question in A3 Due Date 2! But we don't have to do that until the week after the midterm! :D

Other Stuff
    Review:
        String streams:
            Creates an I/O stream, like cin.
            Therefore stringstreams can replace input streams like cin.
            Note: we rarely care about the difference between ostringstream/istringstream, because they just restrict us.

            string s;
            stringstream ss(s);
            stringstream st("5 10 elephant");

            Defining ss doesn't replace cin or cout, it defines a separate stream that we can use however we want.
                cin >> t; // still works
                ss >> t; // also works

                while(ss >> t); // reads into t from ss, ignoring spaces, until there is nothing else in the stream.
                    Each call of "ss >> t" reads the first space-delimited string into t. So "5", then "10", then "elephant".

            Useful stream methods:
                ss.fail(); // fail flag gets set if something goes wrong
                ss.eof(); // gets set if end of line is reached
                ss.clear(); // after failing or EOF, you must clear fail bits
                ss.ignore(); // ignores the next character in the stream (can also take a parameter to ignore n characters?)
                ss.peek(); // looks at the next CHARACTER in the stream without actually taking it out of the stream!
                ss.get(); // ?

            getline(istream, string);
                This looks at the stream you have given it and grabs the entire next line (up until a newline character).
                If stream looked like "Hello\n there everyone!", "Hello" will be put into string.

            See 05/average.cc for a really good example of how to work with getline/stringstreams.

Tip:
    Recovering files from .snapshot in your UW directory
    cd .snapshot
-------------------------------
Tutorial 6

 - Too much stuff.

int *n = new int[0]; // DON'T DO THIS! No memory is actually allocated!
Instead, do:
    int *n = 0;
    int *n = NULL;

Singleton (a design pattern)
    see database.h, database.cc:
        struct Database {
            ...
            static Database *singleton;
            static Database *getInstance();
        }

valgrind -d
valgrind --leak-check-full
----------------------------------
Tutorial 8

Recall the benefits of separate compilation. It's more organized, easier to debug, etc.
    Prevents recompiling of all the things if only one thing changed.

Makefile:
    main.o: book.h book.cc
        g++ -c book.cc

    textbook.o: textbook.h textbook.cc book.h
        g++ -c comic.cc
    ...

    ^^^^ Whitespace MUST be a tab.
    "textbook must be recompiled if book changes, etc."
    make book.o
    Then on the command line, run make
    make is a built-in linux file that looks for "Makefile" (or "makefile")
    make -f otherMakeFileName


    ...
    .PHONY: clean

    clean:
        rm *.o main


    .PHONY says "clean is not a file I want to look at", and lets you run the clean directive.

    Top of Makefile:
        CXX = g++
        CXXFLAGS = -Wall -d -c -etc

        main: ...
            ${CXX} ${CXXFLAGS} main.o book.o textbook.o


        ${EXEC} ...

        g++ -c -MMD lists dependencies

    *Use the given makefile given in svn
    *Know what it looks like for the final exam

Inheritance
    class Tree {
        int data;
    };
    class BTree : public Tree { // "public inheritance"
        // data is still private to Tree

    };

    class Tree {
        protected: // visible to subclasses, gets around getters & setters, not ideal for OOP
        int data;
    }

    virtual keyword: subclasses can overwrite this and those new things can be type-specific
    see phone.cc

    Animal
        Noise
        virtualNoise

    Inherits from Animal:
        Cat
            virtual

        Dog
            Noise
        Fish
            Noise
        Fox
            Virtual

    Inherits from cat:
        Lion

    Inherits from fish:
        Whale
            Virtual
        Shark
            Noise
            Virtual

    "Uses the most recent ancestor's noise/virtualNoise"
    g++ -DPOINTERS
        sets up with pointers
        Animal * pA = ...
--------------------------------------
Tutorial 9

Subject (virtual)
    -obs: Observer
    --------------
    +attach(Observer)
    +detach(Observer)
    +notifyAll()

Observer (virtual)
    +notify()

ConcreteSubject

ConcreteObserver
    +notify()

Note: common cin >> char and cin >> int gotcha:
    -1 will get split into '-' and '1', use  cin >> string and then istringstream(string)

Tip: use gdb to debug segfaults
g++ -g gdbex0.cpp  -->  segmentation fault!
gdb ./a.out
    r run
    print i
    print arr
    break - set breakpoint
    bt - backtrace (print call stack)

Facebook observer example
    Recursively call notify

Taco Decorator example---------------------------------------------
Tutorial 10

Visitor Pattern, Template Pattern, Standard Template Library Stuff

Visitor Pattern Example: Tree

    Visitor (abstract)
        visit(u:unary)
        visit(l:leaf)
        visit(b:binary)

    Printer : Visitor

    Counter : Visitor


    Tree
        -data: string
        +accept(v:Visitor)
        +getData(): string

    Leaf : Tree
        +accept(v:Visitor)

    Unary: Tree
        -child: Tree

    Binary : Tree:
        -left: Tree
        -right: tree


    Leaf::accept(Visitor &v) {
        v.visit(*this);
    }

    int main() {
        Tree * tp = new Unary("foo", new Binary(... , ...))
        Counter c;
        Counter.accept(c)
    }

Another Visitor Example: Rock, Paper, Scissors

    Form
        attack(Form *f)
        defend(Rock &r) // Prints win, lose, or tie
        defend(Paper &r) // Prints win, lose, or tie
        defend(Scissors &r) // Prints win, lose, or tie

    Rock : Form
    Paper : Form
    Scissors : Form

Template Pattern

    Example: Face

    e.g. Game turn calls different parts of a turn sequentially, they can't be manually called out of order.

Standard Template Library

    Auto-resizing vector template

Random Number Generation:

    #include <ctime>
    #include <cstdlib>
    int generate_int() {
        return (rand() % 20) + 1; // [1-20]
    }

Review of Factory

    Factory (abstract)
        +getEnemy()

    Level0 : Factory
        +getEnemy()

    etc.
-------------------------------------
Tutorial 11

Error Catching
    Using error flags is bad practice, because they can be ignored.
        the caller has to manually check for them.

    By raising exceptions, we are being proactive.
        If something breaks, we can't ignore it. We must fix it.

    e.g.
        int main() {
            string s = "Hello";
            for (int i = 0; i <= s.length(); i++) {
                cout << s.at(i) << endl;
            }
        }

        $>./a.out
        H
        e
        l
        l
        o
        terminate called after throwing an instance of 'std::out_of_range'
            what: basic_string::at
        core dumped

    Fixed:
        int main() {
            string s = "Hello";
            try {
                for (int i = 0; i <= s.length(); i++) {
                    cout << s.at(i) << endl;
                }
            } catch (out_of_range r) {
                cout << r.what() << endl;
            }
        }

    "An error is like a baseball. When we throw one we have to catch it somewhere."
    "If I throw a baseball at you, you would probably be liek 'WHAT'?"
        "This is how I remember exception.what().0"

    In C++ you can throw literally anything, including an int, a string, etc.
    Then we would catch (int r), etc.

    We can use 'catch (...)' to catch anything.
                       ^^^ Three actual dots. Literally, '...'.

    This implies that there isn't a strict superclass for exceptions that all of these
    different types inherit from. We are, however, given a few base classes we can use.

    We can create our own exceptions, and even use inheritance.
        struct myexception { ... }
        struct otherexception : public myexception { ... }

    But when we do catch (myexception m) { ... },
    m will behave like myexception, even if we are catching an otherexception.
    Only the superclass' method is called, and the subclass object is sliced.
    To fix this, pass by reference?

Casting
    Recall: const_cast - lets us add/remove 'constness'.

    If we know a Book* contains a TextBook, and we want to call a method
    specific to TextBook, we can static_cast it to a TextBook*.
        If it's not a TextBook*, behaviour is undefined.

    dynamic_cast is the most useful, and lets us check for types at runtime.

    We should feel free use the above three casts (const, static, dynamic).
    But there's one more that we probably shouldn't use that's really fun:
        reinterpret_cast
            Casts anything into anything, with no error checking.
            This is dangerous, but fun.
        e.g.
            struct Witch { ... }
            struct Duck { ... }

            int main() {
                Witch *w1 = new Witch;
                Duck *d1 = new Duck;
                Witch *w2 = new Witch;
                ...
                // witch cast into duck, etc.
                / /see posted example
            }

See svn for an example that combines casting and error-catching.

RIIA (Resource Acquisition Is Initialization)
    As errors are thrown through the stack, and the stack is unwound,
    all of the stack frames are deleted, and memory is being leaked along the way.

    Solution: Instead of using new all over the place, create objects instead of pointers
    that automatically free memory upon destruction.

Auto-Pointers
    Delete is called whenever an auto-pointer goes out of scope.
    "I no longer have to use delete if I use an auto-pointer!"
    Downfalls:
        One place in memory can only be pointed to by exactly one auto-pointer.
        Creating a second auto-pointer? C++ will set the first one to NULL automatically.
        must #include <memory>

    e.g.
        auto_ptr<int> ap(new int);
        *ap = 7;
        cout << *ap << endl;
        // ap.get() returns the pointer (address) being stored.
        // if we create a second identical one, ap.get() returns NULL

    Note: In C++11, we have unique pointers and shared pointers. Yay!
        Unique acts like our auto_ptr
        Shared lets deletes memory only after no more shared pointers point to it.

End of course memes!
    Aragorn: One does not simple learn C++.
    Real Programmers don't comment their code. If it was hard to write, it should be hard to read.
        Note: TAs won't really look at our code for the final project.
    Brace yourselves, C++ questions are coming.
        "Every time I look at Piazza." -Ten
---------------------------------
Final Exam Review
(QA with Kirsten)

Copy Constructors and Assignment Operators with Inheritance
    (Preventing slicing or mixed assignment)

    class Abstract {
        protected:
            int field1;
            int field2;
            ~Abstract()=0;
    };

    class Derived : public Abstract {
        int *field3;
    }

    Derived (const Derived &d) 
        : Abstract(d->abstract) {

    }

    Note: Polymorphism works as long as you don't instantiate the superclass.
        We can't convert one type of Book to, say, a Comic.
        So make Book virtual and use Book pointers as polymorphic pointers that
         can represent any of Book's subclasses.

    Abstract *a = new Student; // Student constructor is called, only a pointer is returned.
        // We don't need a copy constructor implemented for the Abstract class.
    Note: Abstract a = Student; // Probably isn't valid, because we would end up with a virtual object instance.

Factory Design Pattern
    UML:
        Factory
            Factory1
                Creates Things
            Factory2

        Thing (Abstract)
            Thing1
                Constructors
                Destructors
                etc.
            Thing2

    Factory1::getThing() {
        generateNumber(); // Count amount of Things created?
        if (conditionForThing1) {
            Thing *t = new Thing1;
            return t;
        } else {
            return new Thing2;
        }
    }

    Note: Factory doesn't have an arrow to any Thing in the UML.
        Factory simply returns a Thing but never OWNS A or HAS A Thing.
    Note: This lets us have a very simple main file and create various Things
     with our factory on the fly with a method call.
    Note: We could combine singleton with factory so that we only
     have one factory, but this isn't always beneficial.

Foward Declaration
    All we need to do if we don't need to know the size of an object.
        e.g.
            Pointers to a class.
            Reference to a class.
        But not
            Inheriting from a class,
            or passing an argument by value

Visitor Design Pattern
    e.g.
        Note: Slightly tweaked from usual visitor pattern.
        We have three handler methods each with one argument. /* Need to clarify -JR */
        The design of this example may require a bunch of methods, but it's easily expandable!
    UML:
        Form
        + attack(Form *) // Could also be references or objects
        + defend(Rock *)
        + defend(Paper *)
        + defend(Scissors *)
            Rock
            Paper
            Scissors

    void Rock::attack(Form *f) {
        f->defend(this);
    }

    int main() {
        Form *me = new Rock;
        Form *enemy = new Paper;
        me->attack(enemy);
    }

    Note: Form *me; // Must be one of our forms.
        So an array of Form pointers should still dynamically dispatch properly

Bridge and pImpl
    pImpl
        I have a bunch of private fields, but we don't really need to see all of them.
        So let's take all of these private fields and store them in a separate class,
         a class for the implementation, then store a Pointer to the Implementation (pImpl)
        So pImpl just uses a private pointer to the implementation.
        So we don't say "give me Object->x" where x is private.
            We saw it defined but couldn't access it! Argh!
        May also require a few getters and setters to manipulate settings inside the Implementation.
        Note: If we modify the Implementation, we won't have to recompile the superclass,
         since the superclass only contains a pointer to that Implementation.

    Bridge
        Storing a pointer to some other class, like in pImpl, but we abstract away multiple implementations
        e.g.
            Game
            - Window *w

            Window
            + display()
            + drawRectangle()
                OSXWin : public Window
                + display()
                + drawRectangle()
                PCWin : public Window
                + display()
                + drawRectangle()
                LinuxWin : public Window
                + display()
                + drawRectangle()

            So we can to Game->w->draw() regardless of which implementation the Window pointer was set up with.
            Note: We should probably say that Game OWNS A Window, so that the Window is deleted when Game is deleted.

        As a result, we have one interface that we can reuse with various implementations!

OWNS A vs HAS A
    HAS A
        Doesn't delete the things it has when deleted.
        e.g.
            Flood It cells don't need to delete its neighbours when it is deleted,
             since the Grid handles deletion of all the Cells.
    OWNS A
        Deletes objects it owns when it deletes.
        e.g.
            Grid OWNS Cells (and deletes them when Grid is being deleted)
        e.g.
            A Person OWNS their organs, which disappear after death,
             but a Person HAS possessions, which can be given away and reused after death.

Auto Pointers
    auto_ptr<int> n = new int(10);
    auto_ptr<int> m = n; // n is now NULL
    return m;

    Note: auto_ptr<int> iArray = new int[10]; delete iArray; // Only deletes the first element!
        (But ints are base types and C++ takes care of those, but only deleting the first elemnt would cause problems for other objects)
        We don't call 'delete []' on an auto_ptr, only 'delete'!
        So, we should never make an auto pointer point to an array!

    Left as an exercise:
        What happens when we do the following:
            auto_ptr< auto_ptr<int> > n = new int(42);

Template Method
    class Turtle {
        virtual void drawShell()=0;
        virtual void drawFeet();
        virtual void drawHead();
        public:
        void drawTurtle() {
            drawHead();
            drawFeet();
            drawShell();
        }

    class Blue : public Turtle {
        virtual void drawShell() {
            drawSemiCircle("blue");
        }
    }

    Note: If we try to implement drawFeet in the Blue class, it will never be called in Turtle::drawTurtle.
    Note: 'virtual' is not required above in the header 'virtual void drawShell();', it's just a nice sanity check for maintainability.
    "The template pattern thus works kind of like a wrapper function."

Off on a tangent:
    We don't need to know this for the exam, this is more to do with mltiple inheritance (which wasn't covered in class).

    class A {
      protected:
        int data;
    }

    class B : public A {
        string data;
    }

    B b;
    b.data; // returns string
    b.A::data; // returns the int?

Standard Template Library
    Know what iterators are.
    Know what end, rend, push_back, etc. do.
    Know what maps and vectors are.

Partial and Mixed Assignment
    e.g.
        Catching aa bad_cast exception as a generic Exception e.
    e.g.
        Throwing a Textbook and catching as a Book.
            Will splice off the TextBook part of the TextBook.

Note: Understand why you need to recompile some things but not others according to dependencies.
    (This is what a Makefile does)
    We might want to review Makefiles before the final.

Exception Handling

    Study the three levels of exception safety (RAII).
    Study how the stack unwinds as exceptions are thrown up the levels.
        If not caught by main, the program crashes.

    Basic Guaruntee:
        Code is still in a valid state that we can deal with, but something bad happened if we throw.
    Strong Guaruntee:
        Basic + If we throw, everything is in the same state as it was before (atomic).
    No-Throw Guaruntee:
        Strong + Basic + Exceptions won't be thrown.
        The function always succeeds!

    Note: If we throw something and the program is no longer in a valid state, we don't have a name for that.
        No gurauntee!

    Note: Assignment operator with copy-and-swap should be no-throw guarunteed.
        Otherwise if we assign all of our memory before changing our object, we have a strong guaruntee.
    
    try {
        ...
        ___ s;
        throw s;
    } catch (int n) {

    } (string s) {

    } catch (TextBook &t) {

    } catch (...) { // catch anything else

    }
    // other code

    Note: Splicing happens when we catch a TextBook with 'catch (Book b)'.
    Note: 'throw;' just rethrows whatever we just caught.

Coupling and Cohesion
    Two classes that are (highly/closely) coupled:
        Rely on each others' implementations.
        We want low coupling so that we can easily change things.

    A module with high cohesion:
        Everything within that module/class/structure has a similar purpose.
        We want everything related to be in one spot.
        We want high cohesion

    "Remember: Couples are gross, so we want low coupling."

    /* A pneumonic: (L)ow coup(L)ing, (H)igh co(H)esion -JR */
---------------------------------------
Midterm Review

Two Sections:
    Linux
    C++

Bread and butter commands
    ls
    pwd
    diff
    cd
    egrep

Regular Expressions
    . ^ * + ? $
    (expr1 | expr2 | ...)
    [] one occurence of characters listed
    [^ ] one occurence of characters except characters listed
    \ to escape special characters "linux\.student\.cs\.uwaterloo\.ca"

    cs246 or CS246
        egrep "(cs|CS)246"

    Lines with a 4 eventually followed by a 2
        egrep "4.*2"

    Begin with any number of fours then any number of twos
        egrep "^4+2+"

    lines with only a commented out message to cerr
        egrep "^ *// *(std::)?cerr"

Globbing Patterns
    * any number of char
    ? one occurence of any char (like a . in regex)
    {expr1,expr2} OR statement
    [] one of the chars
    [! ] not one of the chars

Difference between regular expressions and globbing expressions:
    Globbing expressions are used/evaluated within the shell before the command is run.
    Regular expressions are broader and evaluated by the command (e.g. egrep).

I/O Redirection
    stdin
    stdout
    cerr

    ./myprog <input.txt > output.txt 2> /dev/null

Piping
    Takes the output of one program and uses it for input of another.
        egrep "^(...)$" /usr/share/dict/words | egrep "[az]" | wc -w

Bash Scripting
    -e -r -x -w -d check various permissions
        -r exists and readable

    -eq -gt -ge -lt -ne compare two integers

    == !=

    echo -n no trailing newline

    #!/bin/bash

    while read line; do
        count=0
        for word in ${line}; do
            count=$(( $count + 1))
            var=$(( $count % 1))
            if [ $var -eq 0 ]; then
                echo -n $word
            fi
        done
        echo ""
    done < file.txt

    {} are optional, but explicitly outline variable names. I would use them every single time.

C++
    Expected to know most of everything from CS136
    if, for, while loops
    functions
    various data types
    pointers

    Strings
        Must #include <string>
        .c_str() returns char*
        .length()
        .substr(n,m) first index n included, m characters 

    Streams
        Must #include <iostream>
        cin, cout, cerr

    #include <sstream>
    string s = "Hello World";
    stringstream ss(s);
    stringstream st("1 2 3 4 5 6");
    ss.str() returns current contents of stringstream as a string

    #include <fstream>
    filestream

    string file = "myfile.out";
    ifstream input("myfile.in");
    ofilestream output("myfile.out");

    Input Stream
        stream >> var attempts to read from stream to var
        s.fail() returns true if the read operation has failed
        s.clear() sets fail flag to false
        s.ignore() ignores next char from stream
        stream.peek() returns next char in stream without removing it

    Dynamic Memory

    MyClass * cp = new MyClass;
    delete cp;
    cp = new MyClass[20]; // array of MyClass of size 20
    delete[] cp;

    Pointers
        int n = 42;
        int * np = 0; // NULL int pointer
        np = &n;
        int * np2 = new int; // pointer to an int on the heap

    References
        Needs to be initialized
        Can't be uninitialized
        Don't need to be dereferenced
        Address it points to cannot be changed

    Default Parameters
        void function(int x = 0, int y = 0); // optional args must be at the end of the parameter list

    Overloading
        We can have multiple functions that have differenct function headers

    int foo(int x);
    int foo(int x, int y = 0); // invalid overload

    Operator Overloading
        >>
        <<
        +
        -
        =
        etc...

    Classes
        Group of related data and methods
        struct Rational{
            int numer, denom
            operator+(const rational &r);

    Methods
        var.method() if var is object
        var->method() if var is a pointer
        this

    Default C constructor s = {1, 2, 3}

    Initialization List
        Describe the steps that a constructor goes through
        1. Allocate Space
        2. Initialize members to default values/initialization list values (in the order they were decalred in)
        3. Execute constructor body
    }

    Copy Constructor
        struct IntClass{
            int * data;

            IntClass(IntClass &n): data(new int(*(n.data))){}
        }

        Default is shallow

        [ value = 5 ]  [  value = 5 ]
        [ next = &B ]  [  next = &B ]
              |             |
              :,_           B
                 "-> [            ]


    Know how to write a deep-copy constructor

    Destructor

    Assignment Operator

        IntClass operator=(IntClass &n){
            if (this == &n)
                return this;
            IntClass temp;
            temp.data = this->data();
            this->data = new int(*(n.data()))
            delete temp;

            return *this;
        }

    Remember the rule of three
        Copy constructor, destructor, assignment operator
        Need to implement all three if you encounter non-continuous space

        int x = 5; assignment operator
        int y = x; copy constructor

    Copy and Swap Idiom

    IntClass& operator=(IntClass n){
        int * temp = n.data;
        n.data = this->data;
        this->data = temp;
        return *this;
    } // destructor called on n when out of scope
    Can the address of n and the address on the left hand side (this) be the same? No.
    this !== &n
    n is a copy of the right hand side, and will have a different address

IntClass & operator= (IntClass & n) {
    IntClass other(n);

    int * temp = other.data;
    other.data = this->data;
    this->data = temp;

    return *this;
}
